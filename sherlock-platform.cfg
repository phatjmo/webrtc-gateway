#!KAMAILIO

# For a registration server, this is what we need:

/*
        JZ Note -- Preventing default option definitions so that they can be activated/deactivated at runtime.
*/

## define WITH_ALIASDB
## define WITH_AUTH # Do not auth for now.
## define WITH_DBTEXT
## define WITH_NAT
## define WITH_NATSIPPING
## define WITH_PRESENCE
## define WITH_USRLOCDB
## define WITH_MULTIDOMAIN
## define WITH_TLS
## define WITH_SIPCAPTURE

#
# Kamailio (OpenSER) SIP Server v4.3 - default configuration script
#     - web: http://www.kamailio.org
#     - git: http://sip-router.org
#
# Direct your questions about this file to: <sr-users@lists.sip-router.org>
#
# Refer to the Core CookBook at http://www.kamailio.org/wiki/
# for an explanation of possible statements, functions and parameters.
#
# Several features can be enabled using '#!define WITH_FEATURE' directives:
#
# *** To run in debug mode: 
#     - define WITH_DEBUG
#
# *** To enable mysql: 
#     - define WITH_MYSQL
#
# *** To enable authentication execute:
#     - enable mysql
#     - define WITH_AUTH
#     - add users using 'kamctl'
#
# *** To enable IP authentication execute:
#     - enable mysql
#     - enable authentication
#     - define WITH_IPAUTH
#     - add IP addresses with group id '1' to 'address' table
#
# *** To enable persistent user location execute:
#     - enable mysql
#     - define WITH_USRLOCDB
#
# *** To enable presence server execute:
#     - enable mysql
#     - define WITH_PRESENCE
#
# *** To enable nat traversal execute:
#     - define WITH_NAT
#     - install RTPProxy: http://www.rtpproxy.org
#     - start RTPProxy:
#        rtpproxy -l _your_public_ip_ -s udp:localhost:7722
#     - option for NAT SIP OPTIONS keepalives: WITH_NATSIPPING
#
# *** To enable PSTN gateway routing execute:
#     - define WITH_PSTN
#     - set the value of pstn.gw_ip
#     - check route[PSTN] for regexp routing condition
#
# *** To enable database aliases lookup execute:
#     - enable mysql
#     - define WITH_ALIASDB
#
# *** To enable speed dial lookup execute:
#     - enable mysql
#     - define WITH_SPEEDDIAL
#
# *** To enable multi-domain support execute:
#     - enable mysql
#     - define WITH_MULTIDOMAIN
#
# *** To enable TLS support execute:
#     - adjust CFGDIR/tls.cfg as needed
#     - define WITH_TLS
#
# *** To enable XMLRPC support execute:
#     - define WITH_XMLRPC
#     - adjust route[XMLRPC] for access policy
#
# *** To enable anti-flood detection execute:
#     - adjust pike and htable=>ipban settings as needed (default is
#       block if more than 16 requests in 2 seconds and ban for 300 seconds)
#     - define WITH_ANTIFLOOD
#
# *** To block 3XX redirect replies execute:
#     - define WITH_BLOCK3XX
#
# *** To enable SIP Capture for Homer
#     - define WITH_SIPCAPTURE
#
# *** To enable VoiceMail routing execute:
#     - define WITH_VOICEMAIL
#     - set the value of voicemail.srv_ip
#     - adjust the value of voicemail.srv_port
#
# *** To enhance accounting execute:
#     - enable mysql
#     - define WITH_ACCDB
#     - add following columns to database
#!ifdef ACCDB_COMMENT
  ALTER TABLE acc ADD COLUMN src_user VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE acc ADD COLUMN src_domain VARCHAR(128) NOT NULL DEFAULT '';
  ALTER TABLE acc ADD COLUMN src_ip varchar(64) NOT NULL default '';
  ALTER TABLE acc ADD COLUMN dst_ouser VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE acc ADD COLUMN dst_user VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE acc ADD COLUMN dst_domain VARCHAR(128) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN src_user VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN src_domain VARCHAR(128) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN src_ip varchar(64) NOT NULL default '';
  ALTER TABLE missed_calls ADD COLUMN dst_ouser VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN dst_user VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN dst_domain VARCHAR(128) NOT NULL DEFAULT '';
#!endif

####### Include Local Config If Exists #########
import_file "kamailio-local.cfg"

####### Defined Values #########

#!ifdef WITH_DBTEXT
#!ifndef DBURL
#!define DBURL "text:///etc/kamailio/dbtext"
#!endif
loadmodule "db_text.so"
modparam("db_text","db_mode",1)
#!endif

# *** Value defines - IDs used later in config
#!ifdef WITH_MYSQL
# - database URL - used to connect to database server by modules such
#       as: auth_db, acc, usrloc, a.s.o.
#!ifndef DBURL
#!define DBURL "mysql://kamailio:kamailiorw@localhost/kamailio"
#!endif
#!endif

#!ifdef WITH_MULTIDOMAIN
# - the value for 'use_domain' parameters
#!define MULTIDOMAIN 1
#!else
#!define MULTIDOMAIN 0
#!endif

# - flags
#   FLT_ - per transaction (message) flags
#        FLB_ - per branch flags
#!define FLT_ACC 1
#!define FLT_ACCMISSED 2
#!define FLT_ACCFAILED 3
#!define FLT_NATS 5

#!define FLB_NATB 6
#!define FLB_NATSIPPING 7

#!define FLT_CAPTURE 22

####### Global Parameters #########

### LOG Levels: 3=DBG, 2=INFO, 1=NOTICE, 0=WARN, -1=ERR
#!ifdef WITH_DEBUG
debug=4
log_stderror=yes
#!else
debug=2
log_stderror=no
#!endif

log_color=no

memdbg=5
memlog=5

log_facility=LOG_LOCAL0

mem_safety=1
mem_join=1
open_files_limit=4096

fork=yes
children=16
tcp_children=16
socket_workers=16

# https://www.kamailio.org/wiki/cookbooks/devel/core#tcp_parameters

# Enables keepalive for tcp (sets SO_KEEPALIVE socket option) (default yes)
tcp_keepalive=yes

# Number of keepalives sent before dropping the connection (TCP_KEEPCNT socket option). Linux only.
tcp_keepcnt=3

# Time before starting to send keepalives, if the connection is idle (TCP_KEEPIDLE socket option). Linux only.
tcp_keepidle=30

# Time interval between keepalive probes, when the previous probe failed (TCP_KEEPINTVL socket option). Linux only.
tcp_keepintvl=30

# Lifetime of orphaned sockets in FIN_WAIT2 state (overrides tcp_fin_timeout on, see linux tcp(7) TCP_LINGER2). Linux only.
tcp_linger2=30

# Control if the received buffer should be cloned from the TCP stream,
# needed by functions working inside the SIP message buffer (such as msg_apply_changes()).
tcp_clone_rcvbuf=1

# life time of TCP connection when there is no traffic
# - a bit higher than registration expires to cope with UA behind NAT
tcp_connection_lifetime=3605

tcp_max_connections=4096

# Time in seconds after a TCP connection will be closed if it is not available
# for writing in this interval (and Kamailio wants to send something on it).
# Lower this value for faster detection of broken TCP connections.
# The default value is 10s.
tcp_send_timeout=10

# Number of SYN retransmissions before aborting a connect attempt (see linux tcp(7) TCP_SYNCNT). Linux only.
tcp_syncnt=3


# Trigger onsend_route() for replies
onsend_route_reply=yes

sip_warning=no
server_signature=yes
server_header="Server: VTCSecure (1.0 (x86_64/linux))"

/* uncomment the next line to disable TCP (default on) */
#disable_tcp=yes

/* uncomment the next line to disable the auto discovery of local aliases
   based on reverse DNS on IPs (default on) */
#auto_aliases=no

/* add local domain aliases */
#alias="sip.mydomain.com"

alias="SIP_DOMAIN"
alias="SIP_DOMAIN:LISTEN_SIP"
#!ifdef WITH_TLS
alias="SIP_DOMAIN:LISTEN_TLS"
#!endif
#!ifdef WITH_WEBRTC
alias="SIP_DOMAIN:LISTEN_WS"
alias="SIP_DOMAIN:LISTEN_WSS"
#!endif
#!ifdef WITH_XMLRPC
alias="SIP_DOMAIN:LISTEN_RPC
#!endif

listen=tcp:LISTEN_IP:LISTEN_SIP advertise PUBLIC_IP:LISTEN_SIP
#!ifdef WITH_TLS
listen=tls:LISTEN_IP:LISTEN_TLS advertise PUBLIC_IP:LISTEN_TLS
#!endif

#!ifdef WITH_WEBRTC
listen=tcp:LISTEN_IP:LISTEN_WS advertise PUBLIC_IP:LISTEN_WS
listen=tls:LISTEN_IP:LISTEN_WSS advertise PUBLIC_IP:LISTEN_WSS
#!endif

#!ifdef WITH_XMLRPC
listen=tcp:LISTEN_IP:LISTEN_RPC advertise PUBLIC_IP:LISTEN_RPC
#!endif

/* port to listen to
 * - can be specified more than once if needed to listen on many ports */
port=LISTEN_SIP
# port=5060
# port=25060

#!ifdef WITH_TLS
enable_tls=yes
#!endif

####### Custom Parameters #########

# These parameters can be modified runtime via RPC interface
# - see the documentation of 'cfg_rpc' module.
#
# Format: group.id = value 'desc' description
# Access: $sel(cfg_get.group.id) or @cfg_get.group.id
#

#!ifdef WITH_PSTN
# PSTN GW Routing
#
# - pstn.gw_ip: valid IP or hostname as string value, example:
# pstn.gw_ip = "10.0.0.101" desc "My PSTN GW Address"
#
# - by default is empty to avoid misrouting
pstn.gw_ip = "" desc "PSTN GW Address"
pstn.gw_port = "" desc "PSTN GW Port"
#!endif

#!ifdef WITH_VOICEMAIL
# VoiceMail Routing on offline, busy or no answer
#
# - by default Voicemail server IP is empty to avoid misrouting
voicemail.srv_ip = "VM_HOST" desc "VoiceMail IP Address"
voicemail.srv_port = "VM_PORT" desc "VoiceMail Port"
#!endif

#!ifdef WITH_WEBRTC
# xHTTP config item
#
# SIP requires a Content-Length header for TCP transport. But most HTTP
# clients do not set the content length for normal GET requests.  
# Therefore, the core must be configured to allow incoming requests without
# content length header:
tcp_accept_no_cl=yes
#!endif

####### Modules Section ########

# set paths to location of modules (to sources or installation folders)
#!ifdef WITH_SRCPATH
mpath="modules/"
#!else
mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/:/usr/lib/kamailio/modules_k/:/usr/lib/kamailio/modules/"
#!endif

#!ifdef WITH_MYSQL
loadmodule "db_mysql.so"
#!endif

loadmodule "mi_fifo.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
loadmodule "textopsx.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "mi_rpc.so"
loadmodule "acc.so"

#!ifdef WITH_REGISTRAR
loadmodule "usrloc.so"
loadmodule "registrar.so"
#!endif

#!ifdef WITH_AUTH
loadmodule "auth.so"
loadmodule "auth_db.so"
#!ifdef WITH_IPAUTH
loadmodule "permissions.so"
#!endif
#!endif

#!ifdef WITH_ALIASDB
loadmodule "alias_db.so"
#!endif

#!ifdef WITH_SPEEDDIAL
loadmodule "speeddial.so"
#!endif

#!ifdef WITH_MULTIDOMAIN
loadmodule "domain.so"
#!endif

#!ifdef WITH_PRESENCE
loadmodule "presence.so"
loadmodule "presence_xml.so"
#!endif

#!ifdef WITH_NAT
loadmodule "nathelper.so"
## loadmodule "rtpproxy.so"
loadmodule "rtpengine.so"
#!endif

#!ifdef WITH_TLS
loadmodule "tls.so"
#!endif

#!ifdef WITH_ANTIFLOOD
loadmodule "htable.so"
loadmodule "pike.so"
#!endif

#!ifdef WITH_XMLRPC
loadmodule "xmlrpc.so"
#!endif

#!ifdef WITH_DEBUG
loadmodule "debugger.so"
#!endif

#!ifdef WITH_XHTTP
loadmodule "xhttp.so"

#!ifdef WITH_WEBRTC
loadmodule "websocket.so"
#!endif

#!endif

loadmodule "uac.so"
loadmodule "http_client.so"

#!ifdef WITH_MSILO
loadmodule "msilo.so"
#!endif

#!ifdef WITH_REGIONS
##loadmodule "exec.so"
#!endif


# ----------------- setting module-specific parameters ---------------


# ----- mi_fifo params -----
# modparam("mi_fifo", "fifo_name", "/var/run/kamailio/kamailio_fifo")

# ----- ctl params -----
# modparam("ctl", "binrpc", "unix:/var/run/kamailio/kamailio_ctl")

# ----- tm params -----
# auto-discard branches from previous serial forking leg
modparam("tm", "failure_reply_mode", 3)
# default retransmission timeout: 30sec
modparam("tm", "fr_timer", 30000) # <-- If INVITE, we set this to 2000 in MANAGE_BRANCH to address stale registrations.
# default invite retransmission timeout after 1xx: 120sec
modparam("tm", "fr_inv_timer", 36000)
# disable auto invite 100 responses
modparam("tm", "auto_inv_100", 0)
modparam("tm", "auto_inv_100_reason", "Please wait as we direct your call")
#!ifdef WITH_MSILO
modparam("tm", "wt_timer", 10000)
#!endif

# ----- rr params -----
# set next param to 1 to add value to ;lr param (helps with some UAs)
modparam("rr", "enable_full_lr", 0)
# do not append from tag to the RR (no need for this script)
modparam("rr", "append_fromtag", 0)
# modparam("rr", "force_send_socket", 1)
modparam("rr", "enable_socket_mismatch_warning", 0)
modparam("rr", "enable_double_rr", 2)

#!ifdef WITH_REGISTRAR
# ----- registrar params -----
modparam("registrar", "method_filtering", 1)
/* uncomment the next line to disable parallel forking via location */
# modparam("registrar", "append_branches", 0)
/* uncomment the next line not to allow more than 10 contacts per AOR */
#modparam("registrar", "max_contacts", 10)
# max value for expires of registrations
modparam("registrar", "max_expires", 3600)
# set it to 1 to enable GRUU
modparam("registrar", "gruu_enabled", 0)

# Disallow case insensitive lookup - per SHERLOCK-690
modparam("registrar", "case_sensitive", 1)

#!ifdef WITH_MSILO
modparam("registrar", "default_expires", 120)
#!endif

#!ifdef WITH_CONTACTSIZE
modparam("registrar", "contact_max_size", 512)
#!endif

#!endif

# ----- acc params -----
/* what special events should be accounted ? */
modparam("acc", "early_media", 0)
modparam("acc", "report_ack", 0)
modparam("acc", "report_cancels", 0)
/* by default ww do not adjust the direct of the sequential requests.
   if you enable this parameter, be sure the enable "append_fromtag"
   in "rr" module */
modparam("acc", "detect_direction", 0)
/* account triggers (flags) */
modparam("acc", "log_flag", FLT_ACC)
modparam("acc", "log_missed_flag", FLT_ACCMISSED)
modparam("acc", "log_extra", 
        "src_user=$fU;src_domain=$fd;src_ip=$si;"
        "dst_ouser=$tU;dst_user=$rU;dst_domain=$rd")
modparam("acc", "failed_transaction_flag", FLT_ACCFAILED)
/* enhanced DB accounting */
#!ifdef WITH_ACCDB
modparam("acc", "db_flag", FLT_ACC)
modparam("acc", "db_missed_flag", FLT_ACCMISSED)
modparam("acc", "db_url", DBURL)
modparam("acc", "db_extra",
        "src_user=$fU;src_domain=$fd;src_ip=$si;"
        "dst_ouser=$tU;dst_user=$rU;dst_domain=$rd")
#!endif

#!ifdef WITH_REGISTRAR
# ----- usrloc params -----
/* enable DB persistency for location entries */
#!ifdef WITH_USRLOCDB
modparam("usrloc", "db_url", DBURL)
# db_mode=2 writes to db on timer (~30s) (best performance), 1 writes directly to DB (slowest). 
modparam("usrloc", "db_mode", 2)
modparam("usrloc", "use_domain", MULTIDOMAIN)
modparam("usrloc", "handle_lost_tcp", 1)
#!endif
#!endif

# ----- auth_db params -----
#!ifdef WITH_AUTH
modparam("auth_db", "db_url", DBURL)
# If password column is plaintext
#modparam("auth_db", "calculate_ha1", yes)
#modparam("auth_db", "password_column", "password")
# If ha1 column is pre-hashed
modparam("auth_db", "calculate_ha1", no)
modparam("auth_db", "password_column", "ha1")
modparam("auth_db", "load_credentials", "email_address")
modparam("auth_db", "use_domain", MULTIDOMAIN)

# ----- permissions params -----
#!ifdef WITH_IPAUTH
modparam("permissions", "db_url", DBURL)
modparam("permissions", "db_mode", 1)
#!endif

#!endif


# ----- alias_db params -----
#!ifdef WITH_ALIASDB
modparam("alias_db", "db_url", DBURL)
modparam("alias_db", "use_domain", MULTIDOMAIN)
#!endif


# ----- speeddial params -----
#!ifdef WITH_SPEEDDIAL
modparam("speeddial", "db_url", DBURL)
modparam("speeddial", "use_domain", MULTIDOMAIN)
#!endif


# ----- domain params -----
#!ifdef WITH_MULTIDOMAIN
modparam("domain", "db_url", DBURL)
# register callback to match myself condition with domains list
modparam("domain", "register_myself", 1)
#!endif


#!ifdef WITH_PRESENCE
# ----- presence params -----
modparam("presence", "db_url", DBURL)

# ----- presence_xml params -----
modparam("presence_xml", "db_url", DBURL)
modparam("presence_xml", "force_active", 1)
#!endif


#!ifdef WITH_NAT
# ----- rtpproxy params -----
# # modparam("rtpproxy", "rtpproxy_sock", "udp:127.0.0.1:7722")
# ----- rtpengine params -----
# modparam("rtpengine", "rtpengine_sock", "udp:rtpengine-registrar-hub-ace.service.consul:5099")
# modparam("rtpengine","extra_id_pv","$avp(rtpengine_extra_id)")
# modparam("rtpengine","setid_avp","$avp(rtpengine_setid)")
# modparam("rtpengine","read_sdp_pv","$avp(rtpengine_sdp)")
# modparam("rtpengine","write_sdp_pv","$avp(rtpengine_sdp)")
# modparam("rtpengine","rtp_inst_pvar","$avp(rtpengine_rtp_instance)")
# modparam("rtpengine","hash_table_size","4096")
# modparam("rtpengine","hash_table_tout","300")
# modparam("rtpengine", "db_url", DBURL)
# modparam("rtpengine", "table_name", "rtpengine")
# modparam("rtpengine", "setid_col", "setid")
# modparam("rtpengine", "url_col", "url")
# modparam("rtpengine", "weight_col", "weight")
# modparam("rtpengine", "disabled_col", "disabled")
# modparam("rtpengine", "setid_default", 0)

/* 
        Load balancing RTPENGINE Hosts. If RTPENGINE_HOST2 is empty, then it won't balance. Possible use for an iteration variable
        RE: http://kamailio.org/docs/modules/stable/modules/rtpengine.html#rtpengine.p.rtpengine_sock
*/
modparam("rtpengine", "rtpengine_sock", "0 == RTPENGINE_HOSTS")
modparam("rtpengine", "rtp_inst_pvar", "$avp(rtpengine_rtp_instance)")

# ----- nathelper params -----
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", FLB_NATSIPPING)
modparam("nathelper", "sipping_from", "sip:pinger@kamailio.org")

# params needed for NAT traversal in other modules
modparam("nathelper|registrar", "received_avp", "$avp(RECEIVED)")
modparam("usrloc", "nat_bflag", FLB_NATB)
#!endif


#!ifdef WITH_TLS
# ----- tls params -----
modparam("tls", "config", "/etc/kamailio/tls.cfg")
#!endif

#!ifdef WITH_ANTIFLOOD
# ----- pike params -----
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 16)
modparam("pike", "remove_latency", 4)
#!endif

# ----- htable params -----
# ip ban htable with autoexpire after 5 minutes
modparam("htable", "htable", "ipban=>size=8;autoexpire=300;dbtable=ipban_htable;dbmode=1")
modparam("htable", "db_url", DBURL)
modparam("htable", "db_expires", 1)
modparam("htable", "timer_procs", 1)

#!ifdef WITH_XMLRPC
# ----- xmlrpc params -----
modparam("xmlrpc", "route", "XMLRPC");
modparam("xmlrpc", "url_match", "^/RPC")
#!endif

#!ifdef WITH_DEBUG
# ----- debugger params -----
modparam("debugger", "cfgtrace", 1)
modparam("debugger", "log_level_name", "exec")
#!endif

#!ifdef WITH_MSILO

modparam("msilo","db_url", DBURL)
modparam("msilo","from_address","sip:$rU@SIP_DOMAIN")
modparam("msilo","contact_hdr","Contact: <sip:$rU@PUBLIC_IP:$Rp;transport=$pr;msilo=yes>\r\n")
modparam("msilo","content_type_hdr","Content-Type: text/plain\r\n")
#modparam("msilo","offline_message","*** User $avp(m_user) is offline ***\r\nYour message will be sent when connection is re-established.")
modparam("msilo", "use_contact", 0)
modparam("msilo", "outbound_proxy", "sip:PUBLIC_IP:LISTEN_SIP;transport=tcp")

#!endif

#!ifdef WITH_REGIONS
modparam("exec", "time_to_kill", 2)
#!endif

#!ifdef WITH_PUSH
loadmodule "cfgutils.so"
loadmodule "tsilo.so"
# loadmodule "app_lua.so" # <-- Do we need to install liblua5.1-dev on the container?
# ----- htable params -----

modparam("htable", "htable","vtp=>size=10;autoexpire=0;dbtable=vtp_htable;dbmode=1")

#!endif

modparam("htable", "htable","morph=>size=10;autoexpire=10800;dbtable=morph_htable;dbmode=1")

#!ifdef WITH_WOOCOMMERCE
modparam("htable", "htable","woocommerce=>size=10;autoexpire=300;dbtable=woocommerce_htable;dbmode=1")
#!endif

loadmodule "ipops.so"

# Load the ENUM module
loadmodule "enum.so"
modparam("enum", "domain_suffix", "itrs.us.")
modparam("enum", "tel_uri_params", ";user=phone")
modparam("enum", "i_enum_suffix", "itrs.us.")
modparam("enum", "branchlabel", "i")

# Allow SDPOps
#!ifdef WITH_SDPOPS
loadmodule "sdpops.so"
#!endif

loadmodule "jansson.so"

#!ifdef WITH_WEBRTC
#modparam("websocket", "keepalive_mechanism", 1)
#modparam("websocket", "keepalive_timeout", 180)
#modparam("websocket", "keepalive_processes", 1)
#modparam("websocket", "keepalive_interval", 1)
#modparam("websocket", "ping_application_data", "WebSockets rock")
#modparam("websocket", "sub_protocols", 1)
modparam("websocket", "cors_mode", 1)
#!endif

#!ifdef WITH_CATAPULT

# --- Parameters for http_client --- #
# http://ap.bandwidth.com/docs/rest-api/messages/
# Use the best of BASIC and Digest authentication.
#modparam("http_client", "authmethod", 3)
#modparam("http_client", "connection_timeout", 2)
#modparam("http_client", "client_cert", "/var/certs/sollentuna.example.com.cert")
#modparam("http_client", "client_key", "/var/certs/sollentuna.example.com.key")
#modparam("http_client", "cacert", "/var/certs/ca/edvina-sip-ca.pem")
#modparam("http_client", "cipher_suites", "ecdhe_ecdsa_aes_128_gcm_sha_256,rsa_aes_128_gcm_sha_256")
#modparam("http_client", "httpcon", "register=>http://annabella:mysecret@atlanta.example.com/api/12")
#modparam("http_client", "httpcon", "messages=>http://annabella:mysecret@atlanta.example.com/api/12")
#modparam("http_client", "httpredirect", 1)
#modparam("http_client", "maxdatasize", 2000)
#modparam("http_client", "tlsversion", 6)
#modparam("http_client", "verify_host", 2)
#modparam("http_client", "verify_peer", 1)
#modparam("http_client", "config_file", "/etc/kamailio/httpconnections.cfg")

# Annoyingly enough, the config_file parameter is broken in http_client, will open ticket but the following seems to work.
modparam("http_client", "httpcon", "bandwidth=>https://BANDWIDTH_TOKEN:BANDWIDTH_SECRET@api.catapult.inetwork.com")

#!endif

modparam("http_client", "httpcon", "pagerduty=>https://events.pagerduty.com")
modparam("http_client", "httpcon", "apn=>APN_URL")
modparam("http_client", "httpcon", "regionapi=>http://api.DNS_DOMAIN:5000")

# --- Parameters for uac --- #
modparam("uac","restore_mode","none") # Note: "auto" requires append_fromtag parameter in RR module.

# https://github.com/kamailio/kamailio/blob/master/doc/dns.txt
dns_try_naptr=on
dns_sctp_pref=-1
dns_udp_pref=-1
dns_tcp_pref=20
dns_tls_pref=10
dns_try_ipv6=no
dns_retr_time=1
dns_retr_no=2
dns_servers_no=1
dns_use_search_list=no

user_agent_header="User-Agent: VTCSecure Sherlock Platform"

pv_buffer_size=4096
pv_buffer_slots=20

####### Routing Logic ########

# Main SIP request routing logic
# - processing of any incoming SIP request starts with this route
# - note: this is the same as route { ... }
request_route {
  # Block all of the nasty sipviscious scanners
  if($fn == "sipviscious" || $tn == "sipviscious") {
    sl_send_reply("403","Lascivious sipvicious");
    exit;
  }

  if (is_method("OPTIONS") && $si == "107.144.9.98") {
    # xlog("L_NOTICE","Found an OPTIONS ping from the VCS, replying 200 OK.\n");
    sl_send_reply("200", "OK");
    exit;
  }

#!ifdef WITH_HOMER
  if (!is_method("REGISTER")) {
    $var(before_du) = $du;
    $du = "sip:HOMER_SERVER:HOMER_PORT;transport=HOMER_PROTOCOL";
    forward();
    $du = $var(before_du);
  }
#!endif

  # Log each non-REGISTER message. Ian hates seeing them.
  if (!is_method("REGISTER")) {
    xlog("L_INFO","$pp: $si:$sp -> $di:$dp [$pr] - $rm $ru - CSeq: $cs - From: <$fu> - To: <$tu> - Contact: <$ct> - CallID: $ci Begin mb\n$mb\nEnd mb\n");

    # cdm = call director message
    # $var(cdm) = "{\"mb\":[],\"pp\":$pp,\"si\":\"$si\",\"sp\":\"$sp\",\"di\":\"$di\",\"dp\":\"$dp\",\"pr\":\"$pr\",\"rm\":\"$rm\",\"ru\":\"$ru\",\"cs\":\"$cs\",\"fu\":\"$fu\",\"tu\":\"$tu\",\"ct\":\"$ct\",\"ci\":\"$ci\"}";
    # $var(i) = 0; \
    # while($var(i)<$(mb{line.count})) {
    #   $var(line)=$(mb{line.at,$var(i)});
    #   jansson_append("string", "mb", "$var(line)", "$var(mb)");
    # }
    # xlog("L_NOTIFY","cdm=>$var(cdm)\n");
 }

  # per request initial checks
  route(REQINIT);
  xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm POST REQINIT\n");

  # NAT detection
  route(NATDETECT);
  xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm POST NATDETECT\n");

  # CANCEL processing
  if (is_method("CANCEL")) {
    if (t_check_trans()) {
      route(RELAY);
    }
    exit;
  }


  # Remember rtcp-fb: on an initial INVITE
  if (is_method("INVITE|UPDATE") && 
    $rb =~ "a=rtcp-fb:") {
    $avp(invite_rtcp_fb)=1;
  } else {
    $avp(invite_rtcp_fb)=0;
  }

  # handle requests within SIP dialogs
  route(WITHINDLG);
  xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm POST WITHINDLG\n");

  ### only initial requests (no To tag)

  # handle retransmissions
  if(t_precheck_trans()) {
    t_check_trans();
    exit;
  }
  t_check_trans();

  xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm POST t_check_trans()\n");

#!ifdef WITH_REGIONS
  route(CHECK_REGION);
#!endif

  #####remove_hf("Route");
# if (is_method("INVITE|SUBSCRIBE|MESSAGE")) {
#   # Add a "Record-Route:" with the transport=tcp
#   if($avp(transport)==$null) {
#     record_route(";transport=$pr");
#     $avp(transport)=1;
#   }
#   # record_route();
#   # route(RECORD_ROUTES); <-- can't do this until after we've determined the routed destination but before t_relay. I'm sure this is going to break in testing! AND IT DID.
# }
#
  # account only INVITEs
  if (is_method("INVITE")) {
    setflag(FLT_ACC); # do accounting
  }

  # If this originated from our private segment in the cloud, treat it as coming from STT
  if (is_in_subnet($si, "HOST_SUBNET")  || is_in_subnet($si, "LISTEN_SUBNET")) {
    xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm RegistrarHub: Found an INVITE arriving from a STT gateway, routing to a registered PUC App: $fU -> $rU\n");
    $avp(source_stt)=1;
    $avp(woocommerce_rstt) = $sht(woocommerce=>stt::$fU);
    $avp(woocommerce_lstt) = $sht(woocommerce=>stt::$rU);
    if($(rU{s.substr,0,5}) == "lstt." || $(rU{s.substr,0,5}) == "rstt.") {
      $rU = $(rU{s.substr,5,0});
      $avp(woocommerce_lstt) = $sht(woocommerce=>stt::$rU);
    }
    if($(rU{s.substr,0,6}) == "glstt." || $(rU{s.substr,0,6}) == "grstt." ||
       $(rU{s.substr,0,6}) == "jlstt." || $(rU{s.substr,0,6}) == "jrstt.") {
      $rU = $(rU{s.substr,6,0});
      $avp(woocommerce_lstt) = $sht(woocommerce=>stt::$rU);
    }
    # Strip the tdd./rtt. prefixes for calls from internal containers
    if($(rU{s.substr,0,4}) == "rtt." ||
       $(rU{s.substr,0,4}) == "tdd.") {
      $rU = $(rU{s.substr,4,0});
    }
    # Strip the glstt/grstt/gbstt prefixes for calls from internal containers
    #if($(rU{s.substr,0,6}) == "glstt." ||
    #   $(rU{s.substr,0,6}) == "grstt." ||
    #   $(rU{s.substr,0,6}) == "gbstt." ||
    #   $(rU{s.substr,0,10}) == "translate.") {
    #  $rU = $(rU{s.substr,6,0});
    #  $avp(destination_solves) = 1;
    #  $avp(recipient_solves) = 1;
    #}
  }

  # If there is still a tdd./rtt. prefix, take note of it and strip it.
#!ifdef WITH_TDD
  if($(rU{s.substr,0,4}) == "rtt.") {
    $avp(calling_rtt)=1;
    $rU = $(rU{s.substr,4,0});
  }
  if($(rU{s.substr,0,4}) == "tdd.") {
    $avp(calling_tdd)=1;
    $rU = $(rU{s.substr,4,0});
  }
#!endif

  # We only have 1 Cisco VCS at the moment
  if ($si == "107.144.9.98") {
    $avp(source_vcs)=1;
  } else {
    $avp(source_vcs)=0;
  }

  if (is_in_subnet($si, "23.253.0.0/16")) {
    xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm Call from Cisco Spark\n");
    $avp(source_spark)=1;
  } else {
    $avp(source_spark)=0;
  }

  xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm PRE whitelist lookup\n");
  # Clever use of enum_pv_query to find if an IP address is whitelisted:
  # Example: 1.104.196.119.242.solves.whitelist.enum.puc.network  NAPTR "E2U+sip" 10 10 "u" "sip:pbx.solves-gce-east1-leo.vatrp.net"
  if(!(defined $avp(source_solves))) {
    $var(wlru)=$ru;
    $var(whitelisted_ip) = $si + ".solves.whitelist.enum.puc.network";
    if(dns_int_match_ip("$var(whitelisted_ip)","127.0.1.1")) {
      xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm Found $var(whitelisted_ip) == 127.0.1.1\n");
      $avp(source_solves)=1;
    } else {
      xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm Did not find $var(whitelisted_ip)\n");
      $avp(source_solves)=0;
    }
    $ru=$var(wlru);
  }
  xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm POST whitelist lookup\n");

#!ifdef WITH_AUTH
  # If this did not originate from our private segment in the cloud, require auth
  xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm Authentication info: adu=$adu aa=$aa ar=$ar au=$au ad=$ad aU=$aU Au=$au\n");
  if (is_in_subnet($si, "HOST_SUBNET")  || is_in_subnet($si, "LISTEN_SUBNET") || $avp(source_vcs) == 1 || $avp(source_solves) == 1 || $avp(source_spark) == 1) {
    xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm Source IP $si originated from HOST_SUBNET or is the VCS, not requiring auth\n");
  } else {
    xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm Source IP $si is from outside of HOST_SUBNET, and is not VCS, requiring auth\n");
    # Challenge for authentication
    route(AUTH);
  }
#!endif

#!ifndef WITH_AUTH
  xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm WARNING: Auth is disabled\n");
#!endif

  xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm POST AUTH\n");

  # Try routing STT
  route(STT);

  # For our authenticated registered endpoints, vouch for their origin IP addresses as per SIP Forum VRS TWG6 RS1.0
  # if (is_method("INVITE")) {
  #   if($hdr(Call-Info)) {
  #     xlog("L_INFO","Call-Info header found: $hdr(Call-Info)\n");
  #   } else {
  #     append_hf("Call-Info: <sip:$si> ;purpose=trs-user-ip\r\n");
  #     xlog("L_INFO","Call-Info header added: $hdr(Call-Info)\n");
  #   }
  # }

  xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm PRE SIPOUT\n");

  # dispatch requests to foreign domains
  route(SIPOUT);

  xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm PRE PRESENCE\n");

  # handle presence related requests
  route(PRESENCE);

  xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm POST PRESENCE\n");

  route(E164_TO);
  route(REGISTRAR);

  xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm POST REGISTRAR\n");

  if ($rU==$null) {
    # request with no Username in RURI
    sl_send_reply("484","Address Incomplete");
    exit;
  }

  route(E164);

  # Store original $rU
  $avp(in-RU) = $rU;

  route(LOCATION);

  # Call STT
  if ($rU == "transcribe") {
    $ru = "sip:transcribe@stt:15060;transport=tcp";
    route(SIPOUT);
    exit;
  }
  if ($rU == "jtranscribe") {
    $ru = "sip:jtranscribe@stt:15060;transport=tcp";
    route(SIPOUT);
    exit;
  }
  if ($rU == "estranscribe") {
    $ru = "sip:estranscribe@stt:15060;transport=tcp";
    route(SIPOUT);
    exit;
  }
  if ($rU == "uktranscribe") {
    $ru = "sip:uktranscribe@stt:15060;transport=tcp";
    route(SIPOUT);
    exit;
  }
  if ($rU == "artranscribe") {
    $ru = "sip:artranscribe@stt:15060;transport=tcp";
    route(SIPOUT);
    exit;
  }
  if ($rU == "cntranscribe") {
    $ru = "sip:cntranscribe@stt:15060;transport=tcp";
    route(SIPOUT);
    exit;
  }
  if ($rU == "brtranscribe") {
    $ru = "sip:brtranscribe@stt:15060;transport=tcp";
    route(SIPOUT);
    exit;
  }
  if ($rU == "frtranscribe") {
    $ru = "sip:frtranscribe@stt:15060;transport=tcp";
    route(SIPOUT);
    exit;
  }

  # ZVRS
  if ($rU == "+18888881116") {
    $ru = "sip:+18888881116@sip-interop.vatrp.net:25060;transport=tcp";
    route(SIPOUT);
    exit;
  }
  # Purple
  if ($rU == "+18774674877") { 
    $ru = "sip:+18774674877@sip-interop.vatrp.net:25060;transport=tcp";
    route(SIPOUT);
    exit;
  }
  # Sorenson Tech support
  if ($rU == "+18012879403") {
    $ru = "sip:+18012879403@vcs.vatrp.net:25060;transport=tcp";
    route(SIPOUT);
    exit;
  }
  # Sorenson QA something something
  if ($rU == "+18015550305") {
    $ru = "sip:+18015550305@sip-interop.vatrp.net:25060;transport=tcp";
    route(SIPOUT);
    exit;
  }
  # Convo
  if ($rU == "+18773637575") {
    $ru = "sip:+18773637575@sip-interop.vatrp.net:25060;transport=tcp";
    route(SIPOUT);
    exit;
  }

  if ($rU == "+1911") {
    xlog("L_INFO","Calling 911 SOLVES\n");
    $ru = "sip:911@pbx.clickvideocall.com:15080;transport=tcp";

    # Make FreeSwitch happy, and don't allow RTT
    # if(sdp_with_media("text"))
    # {
    #   sdp_remove_media("text");
    # }

    $avp(destination_solves)=1;
    route(SIPOUT);
    exit;
  }
  if ($rU == "vra") {
    xlog("L_INFO","Calling vra SOLVES\n");
    $ru = "sip:100030001@pbx.solves-gce-east1-mike.vatrp.org:15080;transport=tcp";

    # Make FreeSwitch happy, and don't allow RTT
    # if(sdp_with_media("text"))
    # {
    #   sdp_remove_media("text");
    # }

    $avp(destination_solves)=1;
    route(SIPOUT);
    exit;
  }
  if ($rU == "leosolves") {
    xlog("L_INFO","Calling leo SOLVES\n");
    $ru = "sip:100010001@pbx.solves-gce-east1-leo.vatrp.org:15080;transport=tcp";

    # Make FreeSwitch happy, and don't allow RTT
    # if(sdp_with_media("text"))
    # {
    #   sdp_remove_media("text");
    # }

    $avp(destination_solves)=1;
    route(SIPOUT);
    exit;
  }

  # Add queue dialing
  if(enum_pv_query("$rU","queue.enum.puc.network.")) {
    xlog("L_INFO","Calling queue at $rU\n");
    $avp(destination_solves)=1;
    route(SIPOUT);
    exit;
  }


  # This must be an iTRS dial-around or P2P call. Look it up in iTRS.
  xlog("L_INFO","iTRS Lookup for: $ru\n");

# if(enum_pv_query("$rU","itrs.us.","+h323")) {
#   $rd = "vcs.puc.network";
#   route(SIPOUT);
#   exit;
# }
# if(enum_pv_query("$rU","itrs.us.","+sip")) {
#   # This is an iTRS dial-around or PTP call
#   xlog("L_INFO","iTRS Lookup success: $ru\n");
#   # If this is a call to ourselves, we didn't catch the endpoint registered earlier
#
#   $rd = "sip-interop.vatrp.net:25060;transport=tcp";
#
# #  if($rd =~ "SIP_DOMAIN") {
# #    xlog("L_INFO","Tried calling one of our numbers which is not registered at the moment: This should go to videomail eventually\n");
# #    send_reply("404", "Tried calling one of our numbers which is not registered at the moment: This should go to videomail eventually");
# #    exit;
# #  }
# #
#   route(SIPOUT);
#   exit;
# }

  # If we're here, and it's a message, this is probably an SMS attempt.
  if(is_method("MESSAGE")){      
#!ifdef WITH_CATAPULT
    xlog("L_INFO","This is likely an SMS message to a non-PUC subscriber: $rU --> route(SMS_SEND)\n");
    if(!(defined $avp(fromnumber))) {
      xlog("L_INFO","Uh oh, this user doesn't have an aliased number, we can't send SMS from this user!");
      sl_send_reply("403","Forbidden");
    } else {
      route(SMS_SEND);
    }
#!else
    xlog("L_INFO","This is likely an SMS message to a non-PUC subscriber, but we don't support that!: $rU --> 403 Forbidden\n");
    sl_send_reply("403","Forbidden");
#!endif
  }
    
  # Try and route to PSTN if possible
  route(PSTN);

  # If this is a call to ourselves, we didn't catch the endpoint registered earlier
  xlog("L_INFO","The dialed destination $rU does not appear to be online.\n");
  send_reply("404", "The number or username you dialed is not associated with a PUC account");
  exit;
}

route[E164] {
  $var(before) = $rU;
  # If prefixed with +1, make sure we only consider the digits
  subst_uri('/^sip:\+1([0-9]{10})@(.*)$/sip:+1\1@\2/ig');

  # If prefixed with 011, that is the NANPA equivalent to +
  subst_uri('/^sip:011([0-9]{0,15}*)@(.*)$/sip:+\1@\2/ig');

  # If prefixed with 1 and followed by exactly 10 digits, it is NANPA, we convert it by stripping the 1 and replacing with +1
  subst_uri('/^sip:1([0-9]{10})@(.*)$/sip:+1\1@\2/ig');

  # If prefixed with anything but a 0 or a 1, insert a +1 (this is ugly, but necessary)
  subst_uri('/^sip:([23456789][0-9]{9})@(.*)$/sip:+1\1@\2/ig');
  # xlog("L_INFO","route[E164]: Result of E.164 conversion: before: $var(before) after: $rU\n");
}

route[E164_TO] {
  $var(ru) = $ru;
  $var(before) = $tU;
  $rU = $tU;

  # If prefixed with +1, make sure we only consider the digits
  subst_uri('/^sip:\+1([0-9]+)@(.*)$/sip:+1\1@\2/ig');

  # If prefixed with 011, that is the NANPA equivalent to +
  subst_uri('/^sip:011([0-9]+)@(.*)$/sip:+\1@\2/ig');

  # If prefixed with 1, we convert it to +1
  subst_uri('/^sip:1([0-9]+)@(.*)$/sip:+1\1@\2/ig');

  # If prefixed with anything but a 0 or a 1, insert a +1
  subst_uri('/^sip:([23456789][0-9]+)@(.*)$/sip:+1\1@\2/ig');
  # $tU = $rU;
  # subst_hf("To","/sip:.*@$/sip:$rU@/", "a");
  # xlog("L_INFO","route[E164]: Result of E.164 conversion: before: $var(before) after: $tU\n");
  $ru = $var(ru);
}

route[STT] {
   xlog("L_NOTIFY","route[STT]: Begin: $rU\n");
  # If this is an INVITE that still has an stt prefix, forward it along to STT
  if(is_method("INVITE")) {
    if($(rU{s.substr,0,5}) == "lstt." || $(rU{s.substr,0,5}) == "rstt." ||
       $(rU{s.substr,0,6}) == "jlstt." || $(rU{s.substr,0,6}) == "jrstt." ||
       $(rU{s.substr,0,6}) == "glstt." || $(rU{s.substr,0,6}) == "grstt." ||
       $(rU{s.substr,0,6}) == "gbstt." || $(rU{s.substr,0,10}) == "translate." ) {
      xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm Endpoint STT call\n");
      if($(rU{s.substr,0,5}) == "lstt.") {
        xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm STT Transcoding local caller: lstt\n");
        $ru = "sip:stt-callers-voice@stt:15060";
      }
      if($(rU{s.substr,0,5}) == "rstt.") {
        xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm STT Watson Transcoding local caller: rstt\n");
        $ru = "sip:stt-responders-voice@stt:15060";
      }
      if($(rU{s.substr,0,6}) == "jlstt.") {
        xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm STT Watson Transcoding local caller: jlstt\n");
        $ru = "sip:jstt-callers-voice@stt:15060";
      }
      if($(rU{s.substr,0,6}) == "jrstt.") {
        xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm STT Watson Transcoding local caller: jrstt\n");
        $ru = "sip:jstt-responders-voice@stt:15060";
      }
      if($(rU{s.substr,0,6}) == "glstt.") {
        xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm STT Google Transcoding local caller: glstt.\n");
        $ru = "sip:lstt@fs:16080";
      }
      if($(rU{s.substr,0,6}) == "grstt.") {
        xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm STT Google Transcoding local caller: grstt.\n");
        $ru = "sip:rstt@fs:16080";
      }
      if($(rU{s.substr,0,6}) == "gbstt.") {
        xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm STT Google Transcoding local caller: gbstt.\n");
        $ru = "sip:bstt@fs:16080";
      }
      if($(rU{s.substr,0,10}) == "translate.") {
        xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm STT Google Transcoding local caller: translate.\n");
        $ru = "sip:bstt@fs:16080";
      }
      $du = $ru + ";transport=tcp";
      $td = "SIP_DOMAIN:LISTEN_SIP;transport=tcp";
      $fd = "SIP_DOMAIN:LISTEN_SIP;transport=tcp";
      xlog("L_NOTIFY","route[STT]: Relaying\n");
      $avp(destination_stt) = 1; # So that we REALLY strip ICE in NATMANAGE.
      $avp(destination_solves) = 1;
      $avp(recipient_solves) = 1;
      route(RELAY);
      exit;
    }
  }
  xlog("L_NOTIFY","route[STT]: End\n");
}

#!ifdef WITH_TDD
route[TDD] {
  xlog("L_NOTIFY","route[TDD]: Begin\n");
  if(is_method("INVITE")) {
    if($avp(calling_tdd) != $null) {
      $ru = "sip:tdd." + $rU + "@fs:16080";
    }
    if($avp(calling_rtt) != $null) {
      $ru = "sip:rtt." + $rU + "@fs:16080";
    }
    if($avp(calling_tdd) != $null ||
       $avp(calling_rtt) != $null) {
      xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm $ru Endpoint TDD call\n");
      $du = $ru + ";transport=tcp";
      $td = "SIP_DOMAIN:LISTEN_SIP;transport=tcp";
      $fd = "SIP_DOMAIN:LISTEN_SIP;transport=tcp";
      xlog("L_NOTIFY","route[TDD]: Relaying\n");
      $avp(destination_stt) = 1; # So that we REALLY strip ICE in NATMANAGE.
      route(RELAY);
      exit;
    }
  }
  xlog("L_NOTIFY","route[TDD]: End\n");
}

#!endif

# Wrapper for relaying requests
route[RELAY] {
  # The destination URI for an ACK should be the Route: header
  # The request URI for an ACK should be the Contact: header
  # Do not blindly assume that $du = $ru always, it isn't true.
  
  # Rewrite the fromdomain carefully, we can't define $fu twice or bad things happen
  $avp(fromdomain) = $fd;
  if($avp(source_solves) == 1) {
    if("$fd" != "SIP_DOMAIN"){
      # We want to make sure the from header originates from this network for outbound SOLVES messages.
      xlog("L_INFO","This message is originating from a SOLVES instance and $fd is not us, fixing that...\n");
      $avp(fromdomain) = "SIP_DOMAIN";
      if($sht(morph=>$fU) == $null){
        if(!$avp(fromnumber)) {
          $avp(fromnumber) = $fU;
        }
      } else {
        xlog("L_INFO","The originating from user: $fU represents a morphed user from a previous transaction: $sht(morph=>$fU), setting from header to match.\n");
        $avp(fromnumber) = $sht(morph=>$fU);
      }

    }
  }

  # What's going on here! If a call or message arrives from a non-subscriber and performs an alias lookup
  # Then there will be no $avp(fromnumber) for in-dialog responses the other direction.
  # This allows both upstream and downstream in-dialog requests to have the correct aliases applied.
  if(is_request() && $avp(pstncall) == 1){

    $var(fu) = $fu;
    if (is_in_subnet($si, "HOST_SUBNET")  || is_in_subnet($si, "LISTEN_SUBNET")) {
      $var(fu) = "sip:" + $fU + "@SIP_DOMAIN";
      xlog("L_INFO","var(fu) = $var(fu)\n");
    }


#!ifdef WITH_AUTH

    if(is_subscriber("$var(fu)","subscriber", "2")) {
      xlog("L_INFO","Request from a subscriber to a non-subscriber: $(C(ps))<$fu> $(C(rs))-->$(C(ps)) <$tu>$(C(xx))\n");
      switch($rdir(name)) {
        case "downstream":
          xlog("L_INFO","In-Dialog request from caller, setting From URI to $(C(ps))$xavp(downstream=>alias)$(C(xx))\n");
          if(defined $xavp(downstream=>alias))
            $fu = $xavp(downstream=>alias);
        break;
        case "upstream":
          xlog("L_INFO","In-Dialog request from callee, setting From URI to $(C(ps))$xavp(upstream=>alias)$(C(xx))\n");
          if(defined $xavp(upstream=>alias))
            $fu = $xavp(upstream=>alias);
        break;
        default:
          xlog("L_INFO","RDIR is $rdir(name): New dialog request, setting From URI to $(C(ps))$avp(fromnumber)$(C(xx))\n");
          if(defined $avp(fromnumber))
            $fu = "sip:"+$avp(fromnumber)+"@"+$avp(fromdomain); # <-- Why not just use $fU? Because writing to $fU is broken!!!
      }
    }
#!endif
  }


  if (!is_method("ACK") ) {
    if(!(defined $du)) {
      $du = $ru;
    }
  }
  
  if (!($du =~  "transport=tcp")) {
    if (!($du =~  "transport=tls")) {
      if($avp(pstncall) == 1) {
        $ru = $ru + ";transport=udp"; # Prefer UDP for PSTN calls.
      }
      $du = $ru + ";transport=tcp"; # Prefer TCP by default. We don't do UDP. At all. Ever. Except PSTN. PSTN is different.
    }
  }

  if($rU != $avp(in-RU) && is_method("MESSAGE") && $avp(in-RU) != $null){
    xlog("L_INFO", "This message's incoming RURI User of $avp(in-RU) has been morphed into $rU, storing $tU in HTABLE for responses.\n");
    $sht(morph=>$rU) = $tU; # $avp(in-RU);
  }

  # enable additional event routes for forwarded requests
  # - serial forking, RTP relaying handling, a.s.o.
  if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
    if(!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
  }
  if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
    if(!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
  }
  if (is_method("INVITE|MESSAGE")) {
    if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
  }
  
  # route(RECORD_ROUTES); # <-- Build the record_route headers based on Protocol -- Moving this to MANAGE_BRANCH for multiple AORs

  # route(NATMANAGE); # DO NOT DO THIS if you also do this again in a branch route, it will duplicate the SDP
  # xlog("L_INFO","route[RELAY]: NATMANAGE returned. BEGIN mb\n$mb\nEND mb\n");
  xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm route[RELAY]: Relaying to $ru [$du] -> LOGTAG\n");
  $avp(odu) = $du;

#!ifdef WITH_VOICEMAIL
  if(is_method("NOTIFY") && has_body("application/simple-message-summary")) {
    xlog("L_INFO","We are about to route an MWI notification, PUC doesn't follow RFC3842 so we need to replace `Voice-Message` with `Voicemail`\n");
    if(subst_body("/^Voice-Message:(.*)$/Voicemail:\1/ig")) xlog("L_INFO","Successfully modified MWI body!\n");
    # PUC doesn't like a to tag so we'll clean that up as well.
    if(subst_hf("To", "/<(.*):(.*)$/<\1:$tU\@SIP_DOMAIN>/", "a")) xlog("L_INFO","Successfully cleaned up NOTIFY To header.\n");
  }
#!endif
#  if(is_method("INVITE") && $avp(destination_solves)) {
#    xlog("L_INFO","Contemplating To: header fixup for INVITE heading to SOLVES.\n");
#    if(subst_hf("To", "/^.*$/<$du>/", "a")) xlog("L_INFO","Successfully cleaned up INVITE To header for SOLVES.\n");
#  }
  sl_send_reply("100", "Attempting relay..."); # <-- Let the UAC know we got this...
  if (!t_relay()) {
    sl_reply_error();
  }
#!ifdef WITH_VOICEMAIL
  if (is_method("BYE") && $fU == $tU) route(MWI); # <-- This was probably a voicemail check, update MWI
#!endif
  xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm route[RELAY]: End -> LOGTAG\n");
  exit;
}

# Per SIP request initial checks
route[REQINIT] {
#!ifdef WITH_ANTIFLOOD
  # flood detection from same IP and traffic ban for a while
  # be sure you exclude checking trusted peers, such as pstn gateways
  # - local host excluded (e.g., loop to self)
  if(src_ip!=myself) {
    if($sht(ipban=>$si)!=$null) {
      # ip is already blocked
      xlog("L_INFO","request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
      exit;
    }
    if (!pike_check_req()) {
      xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm ALERT: pike blocking $rm from $fu (IP:$si:$sp) -> LOGTAG\n");
      sl_send_reply("403", "Too many requests from your IP too rapidly. Blocking you for 5 minutes.");
      $sht(ipban=>$si) = 1;
      exit;
    }
  }
  if($ua =~ "friendly-scanner") {
    sl_send_reply("200", "OK");
    exit;
  }
#!endif

  if (!mf_process_maxfwd_header("10")) {
    sl_send_reply("483","Too Many Hops");
    exit;
  }

  if(is_method("OPTIONS") && uri==myself && $rU==$null) {
    sl_send_reply("200","Keepalive");
    exit;
  }

  if(!sanity_check("1511", "7")) {
    xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm Malformed SIP message from $si:$sp -> LOGTAG\n");
    exit;
  }
}

# Handle requests within SIP dialogs
route[WITHINDLG] {
  if (!has_totag()) return;

# # Remove this at your own peril
# if (is_method("INVITE")) {
#   xlog("L_NOTIFY","WITHINDLG: Adding Record-Route for INVITE|SUBSCRIBER|MESSAGE even with a To-tag – this shouldn’t be needed based on rfc, but maybe some UAs don't follow that -> LOGTAG\n");
#   # record_route();
#   if($avp(transport)==$null) {
#     record_route(";transport=$pr");
#     $avp(transport)=1;
#   }
# }

  if( is_method("ACK") || is_method("INFO") ) {
    if ($ru =~ "<") {
      xlog("L_INFO","TEST CALL: SIPp didn't parse Contact header correctly for [next_url], fixing...\n");
      # Sample URI we are fixing: 'sip:phatjmo@68.109.133.210:57894;transport=tcp;alias=68.109.133.210:57894~2>;+sip.instance="<urn:uuid:0f35feab-c878-4622-a94e-b2e6e812b177 '
      xlog("L_INFO","R-URI before fixup: $ru\n");
      $var(dirtyuri)=$ru;
      $ru=$(var(dirtyuri){s.select,0,>});
      xlog("L_INFO","R-URI after fixup: $ru \n");
    }
  }


  # sequential request withing a dialog should
  # take the path determined by record-routing
  if (loose_route()) {
    route(DLGURI);
    if (is_method("BYE")) {
      setflag(FLT_ACC); # do accounting ...
      setflag(FLT_ACCFAILED); # ... even if the transaction fails
    } else if ( is_method("ACK") ) {
      # ACK is forwarded statelessy
      route(NATMANAGE);

      # Ensure the destination URI is to the first Route: header hop
      # Do not touch $ru, as it should be the Contact: header from the response this is ACKing
      # if (defined $hdr(Route)) {
      #   $du = $hdr(Route)[0];
      # }

      # if (!lookup("location")) {
      #   xlog("L_ALERT","route[WITHINDLG]: ru is not a valid location: $ru -> LOGTAG\n");
      #   $ru=$tu;        
      # }
      # if($tU == "911") {
      #   $ru=$fu;
      #   $var(found) = lookup("location");
      #   xlog("L_INFO","route[WITHINDLG]: lookup(location) for $ru returned: $var(found) -> LOGTAG\n");
      #   if (!$var(found)) {
      #     xlog("L_ALERT","route[WITHINDLG]: fu is not a valid location: $ru -> LOGTAG\n");
      #   }
      # }
      #   if($(rU{s.substr,0,5}) == "lstt." || $(rU{s.substr,0,5}) == "rstt.") {
      #     $rU = $(rU{s.substr,5,0});
      #     if (!lookup("location")) {
      #       xlog("L_ALERT","route[WITHINDLG]: tu is not a valid location: $ru -> LOGTAG\n");
      #     }
      #   }
      #   xlog("L_ALERT","route[WITHINDLG]: Recording the route to $ru -> LOGTAG\n");
    }
      # else if ( is_method("NOTIFY") ) {
      #   # Add Record-Route for in-dialog NOTIFY as per RFC 6665.
      #   # record_route();
      #   if($avp(transport)==$null) {
      #     record_route(";transport=$pr");
      #     $avp(transport)=1;
      #   }
      #                }
    xlog("L_NOTIFY","$TF $pp $si:$sp [$ci:$cs] $rm route[WITHINDLG]: Relaying $rm to $ru [$du] -> LOGTAG\n");
    route(RELAY);
    exit;
  }

  if (is_method("SUBSCRIBE") && uri == myself) {
    xlog("L_NOTIFY","$TF $pp $si:$sp [$ci:$cs] $rm route[WITHINDLG]: Presence $rm found -> LOGTAG\n");
    # in-dialog subscribe requests
    route(PRESENCE);
    exit;
  }
  if ( is_method("ACK") ) {
    if ( t_check_trans() ) {
      xlog("L_NOTIFY","$TF $pp $si:$sp [$ci:$cs] $rm route[WITHINDLG]: Transactional ACK found, relaying -> LOGTAG\n");

      # no loose-route, but stateful ACK;
      # must be an ACK after a 487
      # or e.g. 404 from upstream server
      route(RELAY);
      exit;
    } else {
      xlog("L_NOTIFY","$TF $pp $si:$sp [$ci:$cs] $rm route[WITHINDLG]: ACK without matching transaction. Ignoring and discarding -> LOGTAG\n");
      # ACK without matching transaction ... ignore and discard
      exit;
    }
  }
  if(is_method("NOTIFY")){
    xlog("L_INFO","NOTIFY with a To Tag that isn't in-dialog: Returning to request route.\n");                       
    return;                                                                                                          
  } 

  sl_send_reply("404","Not here");
  exit;
}

# Handle SIP registrations
route[REGISTRAR] {
  if (!is_method("REGISTER")) return;

  $ru = $tu;

  route(E164);

  if($hdr(Expires) <= 1) {
    xlog("L_NOTIFY","$TF $pp $si:$sp [$ci:$cs] $rm route[REGISTRAR]: CSeq: $cs Expires is 0 or 1, immediately unregistering $ru -> ct: $ct\n");
    unregister("location", "$ru");
    exit;
  }

  if(isflagset(FLT_NATS)) {
    setbflag(FLB_NATB);
#!ifdef WITH_NATSIPPING
    # do SIP NAT pinging
    setbflag(FLB_NATSIPPING);
#!endif
  }

  # 0x01 to NOT WRITE TO USRLOCDB!!! 0 ignores flags.
  if (!save("location", "0", "$ru")) {
    xlog("L_NOTIFY","$TF $pp $si:$sp [$ci:$cs] $rm route[REGISTRAR]: CSeq: $cs ERROR saving registration for ru: $ru  tu: $tu  fu: $fu [$si:$sp] -> ct: $ct\n");
    sl_reply_error();
    exit;
  }

#!ifdef WITH_PUSH
  # If the Expires header is greater than 1, try to join future pushes
  if($hdr(Expires) > 1) {
    route(PUSHJOIN);
## FIXME: Temporarily disabled: Do not leave pushes on Expires: 0 or 1
## Android presently _always_ Expires: 0, and iOS presently _always_ Expires: 1
#  } else {
#    # If the Expires header is 0, forget about push notifications
#    route(PUSHLEAVE);
  }
#!endif

  xlog("L_NOTIFY","$TF $pp $si:$sp [$ci:$cs] $rm route[REGISTRAR]: CSeq: $cs Saved registration for ru: $ru  tu: $tu  fu: $fu [$si:$sp] -> ct: $ct\n");
# MSILO - dumping user's offline messages
#!ifdef WITH_MSILO
  if (m_dump()) {
    xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm MSILO: offline messages dumped.\n");
  } else {
    xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm MSILO: no offline messages dumped\n");
  };
#!endif
#!ifdef WITH_VOICEMAIL
  # Querying Voicemail Server and generating MWI NOTIFY
  if($hdr(Expires) > 0) route(MWI);
#!endif
  exit;
}

# User location service
route[LOCATION] {

  $var(user) = $(rU{re.subst,/^1?([0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9])$/+1\1/});
  $rU = $var(user);
  $avp(m_user) = $rU;

  $var(fu) = $fu;
  if (is_in_subnet($si, "HOST_SUBNET")  || is_in_subnet($si, "LISTEN_SUBNET")) {
    $var(fu) = "sip:" + $fU + "@SIP_DOMAIN";
    xlog("L_INFO","var(fu) = $var(fu)\n");
  }

#!ifdef WITH_SPEEDDIAL
  # search for short dialing - 2-digit extension
  if($rU=~"^[0-9][0-9]$")
    if(sd_lookup("speed_dial"))
      route(SIPOUT);
#!endif

#!ifdef WITH_VOICEMAIL
  if(($tU == $fU) && !is_method("NOTIFY|MESSAGE")){
    xlog("L_INFO","Caller is calling themselves, this looks like a VOICEMAIL access attempt, let's see if the caller is a registered user.\n");
    if (registered("location", "$tu")) {
      xlog("L_INFO","Caller is registered, so this is legit, sending to VOICEMAIL.\n");
      if ($tU!=$null) {
        $avp(oexten) = $tU;
      }
      route(TOVOICEMAIL);
    } else {
      xlog("L_INFO","Caller is not registered, this doesn't seem to be a legitimate voicemail access attempt.\n");
      # We don't necessarily want to reject this call, so for now, fail out to regular routing.
      return;
    }
  }
#!endif

#!ifdef WITH_AUTH
  if(is_subscriber("$var(fu)","subscriber", "3") && is_subscriber("$ru","subscriber", "3")) {
    xlog("L_INFO","route[LOCATION]: Call from $fU to $rU is obviously an internal network communication, skip all the Alias DB garbage.\n");

      # Check From user for Woocommerce flagged Speech to Text
#!ifdef WITH_WOOCOMMERCE
    if(is_method("INVITE")) {
      if($avp(woocommerce_rstt) == $null){
        $avp(woocommerce_rstt) = $sht(woocommerce=>stt::$fU);
        if($avp(woocommerce_rstt) != $null){
          if (!is_in_subnet($si, "HOST_SUBNET")  && !is_in_subnet($si, "LISTEN_SUBNET")) {
            $rU = "grstt.$rU";
            route(STT);
          }
        }
      }
    }
#!endif

      # Check Request user for Woocommerce flagged Speech to Text
#!ifdef WITH_WOOCOMMERCE
    if(is_method("INVITE")) {
      if($avp(woocommerce_lstt) == $null){
        # Deal with inbound PSTN rewriting
        $var(woocommerce_rU) = $rU;
        if($(rU{s.substr,0,5}) == "lstt." || $(rU{s.substr,0,5}) == "rstt.") {
          $rU = $(rU{s.substr,5,0});
        }
        if($(rU{s.substr,0,6}) == "glstt." || $(rU{s.substr,0,6}) == "grstt.") {
          $rU = $(rU{s.substr,6,0});
        }
        $avp(woocommerce_lstt) = $sht(woocommerce=>stt::$rU);
        if($avp(woocommerce_lstt) != $null){
          if (!is_in_subnet($si, "HOST_SUBNET")  && !is_in_subnet($si, "LISTEN_SUBNET")) {
            $rU = "glstt.$rU";
            route(STT);
          }
        } else {
          $rU = $var(woocommerce_rU);
        }
      }
    }
#!endif

    # This may be a tdd test call from username to username, check it
#!ifdef WITH_TDD
    route(TDD);
#!endif

  } else {
#!ifdef WITH_ALIASDB
    # Is the from URI a subscriber?
    if(is_subscriber("$var(fu)","subscriber", "3")) {
      xlog("L_NOTIFY","Found $fu as a subscriber: $ru\n");
      # Rewrite the From: address of an aliased caller.
      # Backup the original request URI

      # Check From user for Woocommerce flagged Speech to Text
#!ifdef WITH_WOOCOMMERCE
      if(is_method("INVITE")) {
        if($avp(woocommerce_rstt) == $null){
          $avp(woocommerce_rstt) = $sht(woocommerce=>stt::$fU);
          if($avp(woocommerce_rstt) != $null){
            $rU = "grstt.$rU";
            route(STT);
          }
        }
      }
#!endif

      # This might be a tdd test call from phone number to username, check it
#!ifdef WITH_TDD
      route(TDD);
#!endif

      $var(ru)=$ru;
      $ru=$fu;
      if (alias_db_lookup("subscriber_pstn_aliases")) {
        xlog("L_NOTIFY","route[LOCATION]: PSTN Aliased fu $fu to $ru\n");
        # $fu = $ru; # <-- Really shouldn't do this here.
        $avp(fromnumber)=$rU;
        $xavp(downstream=>alias) = $ru;
      } else {
        xlog("L_NOTIFY","Did not find PSTN alias for $fu ($ru), checking user defined aliases...\n");
        if (alias_db_lookup("dbaliases")) {
          xlog("L_NOTIFY","route[LOCATION]: Aliased fu $fu to $ru\n");
          # $fu = $ru; # <-- Really shouldn't do this here.
          $avp(fromnumber)=$rU;
          $xavp(downstream=>alias) = $ru;
        } else {
          xlog("L_NOTIFY","Did not find any aliases for $fu ($ru)\n");
        }
      }
      # Restore the original request URI back
      $ru=$var(ru);
    } else {
      xlog("L_NOTIFY","Did not find $fu as a subscriber\n");
    }

    # Is the request URI to a non-subscriber?
    if(!is_subscriber("$ru","subscriber", "3")) {
      # Try looking up the $ru of a dialed phone number
#!ifdef WITH_REGISTRAR
      # Search in DB-based aliases _before_ doing the number lookup (lookup up username from number)
      # NOTE: This might also end up being a username lookup turning into a phone number, which will not be found.
      # Store the original dial string
      $var(ruinitial) = $ru;
      $var(rUinitial) = $rU;
      route(E164);
      xlog("L_NOTIFY","$TF $pp $si:$sp [$ci:$cs] $rm route[LOCATION]: Initially looking up $ru - $tu\n");
      if (alias_db_lookup("subscriber_pstn_aliases")) {
        xlog("L_NOTIFY","$TF $pp $si:$sp [$ci:$cs] $rm route[LOCATION]: Initially aliased ru $var(ruinitial) to $ru\n");
        $avp(oexten) = $rU;
        $avp(pstnaliasedto) = $rU;
        # Request URI is now rewritten from a phone number to a username

        # Check PSTN aliased Request URI user for Woocommerce flagged Speech to Text
#!ifdef WITH_WOOCOMMERCE
        if(is_method("INVITE")) {
          if($avp(woocommerce_lstt) == $null){
            # Deal with inbound PSTN rewriting
            $var(woocommerce_rU) = $rU;
            if($(rU{s.substr,0,5}) == "lstt." || $(rU{s.substr,0,5}) == "rstt.") {
              $rU = $(rU{s.substr,5,0});
            }
            if($(rU{s.substr,0,6}) == "glstt." || $(rU{s.substr,0,6}) == "grstt.") {
              $rU = $(rU{s.substr,6,0});
            }
            $avp(woocommerce_lstt) = $sht(woocommerce=>stt::$rU);
            if($avp(woocommerce_lstt) != $null){
              if (!is_in_subnet($si, "HOST_SUBNET")  && !is_in_subnet($si, "LISTEN_SUBNET")) {
                $rU = "glstt.$rU";
                route(STT);
              }
            } else {
              $rU = $avp(woocommerce_rU);
            }
          }
        }
#!endif

        # This might be a tdd test call from a username to username, try it
#!ifdef WITH_TDD
        route(TDD);
#!endif

        # $avp(tonumber) = $var(rUinitial);
        $xavp(upstream=>alias) = $var(ruinitial);
        route(CHECK_LOC);
        # Restore the original dial string
        $ru = $var(ruinitial);
      } else {
        xlog("L_NOTIFY","Did not find any PSTN aliases for ($ru), checking user defined aliases...\n");
        if (alias_db_lookup("dbaliases")) {
          xlog("L_NOTIFY","$TF $pp $si:$sp [$ci:$cs] $rm route[LOCATION]: Initially aliased ru $var(ruinitial) to $ru\n");
          $avp(oexten) = $rU;
          $avp(pstnaliasedto) = $rU;
          # Request URI is now rewritten from a phone number to a username

          # Check dbaliased Request URI user for Woocommerce flagged Speech to Text
#!ifdef WITH_WOOCOMMERCE
          if(is_method("INVITE")) {
            if($avp(woocommerce_lstt) == $null){
              # Deal with inbound PSTN rewriting
              $var(woocommerce_rU) = $rU;
              if($(rU{s.substr,0,5}) == "lstt." || $(rU{s.substr,0,5}) == "rstt.") {
                $rU = $(rU{s.substr,5,0});
              }
              if($(rU{s.substr,0,6}) == "glstt." || $(rU{s.substr,0,6}) == "grstt.") {
                $rU = $(rU{s.substr,6,0});
              }
              $avp(woocommerce_lstt) = $sht(woocommerce=>stt::$rU);
              if($avp(woocommerce_lstt) != $null){
                if (!is_in_subnet($si, "HOST_SUBNET")  && !is_in_subnet($si, "LISTEN_SUBNET")) {
                  $rU = "glstt.$rU";
                  route(STT);
                }
              } else {
                $rU = $var(woocommerce_rU);
              }
            }
          }
#!endif

          # This might be a tdd test call from username to contact phone number, try it
#!ifdef WITH_TDD
          route(TDD);
#!endif

          # $avp(tonumber) = $var(rUinitial);
          $xavp(upstream=>alias) = $var(ruinitial);
          route(CHECK_LOC);
          # Restore the original dial string
          $ru = $var(ruinitial);
        } else {
          xlog("L_NOTIFY","Did not find any aliases for ($ru).\n");
        }
      }
#!endif
    }
#!endif
  }
#!endif

  # Try looking up the $ru of the username
#!ifdef WITH_REGISTRAR
  xlog("L_NOTIFY","$TF $pp $si:$sp [$ci:$cs] $rm route[LOCATION]: Subsequently looking up $ru - $tu\n");
  $var(rusubsequent) = $ru;
  $var(rUsubsequent) = $rU;
  route(CHECK_LOC);
  $ru = $var(rusubsequent);

#!endif

  # when routing via usrloc, log the missed calls also
  if (is_method("INVITE")) {
    setflag(FLT_ACCMISSED);
  }
}

route[CHECK_LOC] {
  xlog("L_NOTIFY","$TF $pp $si:$sp [$ci:$cs] $rm route[CHECK_LOG]: Begin: $ru [$du] - $tu\n");
  if($rU==$null) {
    $rU = $avp(pstnaliasedto);
    xlog("L_NOTIFY","$TF $pp $si:$sp [$ci:$cs] $rm route[CHECK_LOG]: Begin: rU is null, using $rU instead");
  }
  if (lookup("location")) {
    $avp(trsuserip) = $rd;
    xlog("L_NOTIFY","$TF $pp $si:$sp [$ci:$cs] $rm route[LOCATION]: Initially found $ru [$du] - $tu\n");
    # Prepare videomail outbound extension just in case
    $avp(oexten) = $rU;
#!ifdef WITH_PUSH
    route(T_STORE);
#!endif
    route(RELAY);
    exit;
  } else {
    xlog("L_NOTIFY","$TF $pp $si:$sp [$ci:$cs] $rm route[LOCATION]: Did not initially find $ru [$du] - $tu\n");
#!ifdef WITH_AUTH
    if (is_subscriber("$ru", "subscriber", "3")) {
      xlog("L_INFO","Found subscriber [$ru]; -> LOGTAG");
#!ifdef WITH_PUSH
      route(TRYPUSH);
#!endif
#!ifdef WITH_MSILO
      route(M_STORE);
#!endif
#!ifdef WITH_VOICEMAIL
      if($rU!=$null) {
        $avp(oexten) = $rU;
      }
      route(TOVOICEMAIL);
#!endif
    } 
#!endif

  }
}

#!ifdef WITH_MSILO
# MSILO Message Storage
route[M_STORE]{
  if(is_method("MESSAGE") && (src_ip != myself || $hdr(X-SMS) == "Yes") && !($avp(destination_solves) == 1 || $avp(recipient_solves) == 1)){
    xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm MESSAGE received -> storing using MSILO\n");
    t_newtran();
    # MSILO - storing as offline message
    if($hdr(Content-Type) =~ "im-iscomposing") {
      xlog("L_INFO","$(C(ps))MSILO: Provisional im-iscomposing message, ignoring!!!$(C(xx))\n");
      t_reply("202","Accepted");
      exit;
    } else if ($mb =~ "is offline ***") {
      xlog("L_INFO","$(C(ps))MSILO: Failure on offline message notification, ignoring!!!$(C(xx))\n");
      t_reply("202","Accepted");
    } else {
      if(search_body("Your message will be sent when connection is re-established.")) {
          xlog("L_INFO","$(C(ps))MSILO: Automated answer to offline advisory message, ignoring!!!$(C(xx))\n");
      } else { 
          if (m_store("$ru")) {
            xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm MSILO: offline message stored\n");
            if (!t_reply("202", "Accepted")) {
              sl_reply_error();
            };
            exit;
          } else {
            xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm MSILO: offline message NOT stored\n");
            if (!t_reply("503", "Service Unavailable")) {
              sl_reply_error();
            };
            exit;
          };
        }
     }
  }
  return;
}

#!endif

#!ifdef WITH_PUSH
# suspend the transaction

route[T_STORE]{
  if(t_newtran()){
    ts_store();
    $var(storedindex) = $shtcn(vtp=>%~stored::$rU) + 1;
    $sht(vtp=>stored::$rU-$var(storedindex)) = 1;
    xlog("L_INFO","stored transaction [$T(id_index):$T(id_label)] $fU=> $rU\n");
  }
}

route[TRYPUSH] {
  if(!is_method("INVITE|MESSAGE")) 
    return;
 
  # PUC-2055
  if(is_method("MESSAGE")) {
    if($hdr(Content-Type) =~ "im-iscomposing") {
      return;
    }
  }

  if(!strempty($sht(vtp=>token::$rU))) {
    xlog("L_INFO","The subscriber $ru has an iOS device with token $sht(vtp=>token::$rU), we should try to wake it up!\n");
    send_reply("100", "Trying");
    route(SENDPUSH);
    route(SUSPEND);
    exit;
  } else {
    xlog("L_INFO","The subscriber $ru does not have a PN token $sht(vtp=>token::$rU), skipping to VOICEMAIL!\n");
    return;
  }
  
}

route[SUSPEND] {
  # Setting the FR Timer low so that we can properly fail the transaction if the push is delayed or the device does not wake up.
  # If it is a MESSAGE, we set the timer high to avoid delays in re-REGISTER when there are multiple messages in a row.
  if(is_method("MESSAGE")) {
    t_set_fr(120000,120000);
  } else {
    t_set_fr(36000,36000);
  }
  t_on_failure("PUSH_FAILURE");
  if(!t_suspend()){
    xlog("L_INFO","failed suspending trasaction [$T(id_index):$T(id_label)]\n");
    send_reply("501", "Unknown destination");
    exit;
  }
  xlog("L_INFO","suspended transaction [$T(id_index):$T(id_label)] $fU=> $rU\n");
  $var(suspendindex) = $shtcn(vtp=>%~join::$rU) + 1;
  $sht(vtp=>join::$rU-$var(suspendindex)) = "" + $T(id_index) + ":" +$T(id_label);
  xlog("L_INFO","htable key value [$sht(vtp=>join::$rU-$var(suspendindex))]\n");
}

route[SENDPUSH] {

  if(is_method("INVITE") && $hdr(Content-Type) =~ "im-iscomposing") {
    xlog("L_INFO","$(C(ps))SENDPUSH: Provisional im-iscomposing message, ignoring!!!$(C(xx))\n");
    t_reply("202","Accepted");
    exit;
  }
  # Now we are going to pass this through a proxy API-server
  # { 
  #   "app-id" : "com.vtcsecure.puc.ios.dev",
  #   "pn-type" : "apple",
  #   "pn-tok" : "D0E0F44DC486889530E77C665528E514053DDA87319C1800105A7633AED013CE",
  #   "pn-msg-str" : "IM_MSG",
  #   "pn-call-str" : "IC_MSG", 
  #   "pn-call-snd" : "ring.caf", 
  #   "pn-msg-snd" : "msg.caf"
  # }

  jansson_set("string", "app-id", $sht(vtp=>appid::$rU), "$var(pushjson)");
  jansson_set("string", "pn-type", $sht(vtp=>type::$rU), "$var(pushjson)");
  jansson_set("string", "pn-tok", $sht(vtp=>token::$rU), "$var(pushjson)");
  jansson_set("string", "pn-msg-str", $sht(vtp=>msgstr::$rU), "$var(pushjson)");
  jansson_set("string", "pn-call-str", $sht(vtp=>callstr::$rU), "$var(pushjson)");
  jansson_set("string", "pn-call-snd", $sht(vtp=>callsnd::$rU), "$var(pushjson)");
  jansson_set("string", "pn-msg-snd", $sht(vtp=>msgsnd::$rU), "$var(pushjson)");
  jansson_set("string", "method", $rm, "$var(pushjson)");
  jansson_set("string", "from", $fu, "$var(pushjson)");
  jansson_set("string", "to", $ru, "$var(pushjson)");
  # if (is_present_hf("Route")){
  #   xlog("L_INFO", "Looks like this is an in-dialog push notification, sending call-id: $ci\n");
  #   jansson_set("string", "call-id", $ci, "$var(pushjson)");
  # }  
  #We need to do this the hard way, with http_client and figuring out the device ID from the contact header
  xlog("L_INFO", "Attempting to send PUSH Notification to APN_URL with json:\n$var(pushjson)\n");
  $var(res) = http_connect("apn", "", "application/json", "$var(pushjson)", "$avp(pushresult)");
  
  xlog("L_INFO", "Push Notification HTTP connection: $avp(pushresult) Result code $var(res)\n");
  if($var(res) == 200){
    xlog("L_INFO","Looks like our PUSH went out, now we suspend and wait for $rU to re-REGISTER.\n");
    $avp(sentpush) = 1;
    if(is_method("INVITE")) {
      send_reply("180", "Ringing");
    }
  } else {
    xlog("L_INFO","Looks like our PUSH request failed, sending an ERROR back to the caller.\n");
#!ifdef WITH_MSILO
    route(M_STORE);
#!else
    send_reply("501", "Unknown destination");
#!endif
    exit;    
  }
}

# Leave the push notifications: Remove htable vtp named entries
route[PUSHLEAVE] {
  xlog("L_INFO","PUSHLEAVE $tU\n");
  sht_rm_name_re("vtp=>stored::$tU");
  sht_rm_name_re("vtp=>join::$tU");
  sht_rm_name_re("vtp=>appid::$tU");
  sht_rm_name_re("vtp=>token::$tU");
  sht_rm_name_re("vtp=>type::$tU");
  sht_rm_name_re("vtp=>msgstr::$tU");
  sht_rm_name_re("vtp=>callstr::$tU");
  sht_rm_name_re("vtp=>callsnd::$tU");
  sht_rm_name_re("vtp=>msgsnd::$tU");
}

# append branches or resume the transaction
route[PUSHJOIN] {
  if(!is_method("REGISTER")){
    return;
  }
  if($ct =~ "pn-tok"){
    xlog("L_INFO","$ct has a push notification token!\n");
  } else {
    xlog("L_INFO","$ct does not have a push notification token! Returning without storing.\n");
    route(PUSHLEAVE);
    return;
  }
  $var(hjoin) = 0;
  lock("$tU");

  # Clear out any other tokens for this push-token
  sht_rm_value_re("vtp=>$(ct{param.value,pn-tok})");
  
  # $sht(vtp=>token::$tU) = $(ct{uri.param,pn-tok}); # <-- $ct does not provide a valid URI in this case.
  # $sht(vtp=>type::$tU) = $(ct{uri.param,pn-type});
    
  $sht(vtp=>appid::$tU) = $(ct{param.value,app-id});
  $sht(vtp=>token::$tU) = $(ct{param.value,pn-tok});
  $sht(vtp=>type::$tU) = $(ct{param.value,pn-type});
  $sht(vtp=>msgstr::$tU) = $(ct{param.value,pn-msg-str});
  $sht(vtp=>callstr::$tU) = $(ct{param.value,pn-call-str});
  $sht(vtp=>callsnd::$tU) = $(ct{param.value,pn-call-snd});
  $sht(vtp=>msgsnd::$tU) = $(ct{param.value,pn-msg-snd});

  unlock("$tU");
  if(!strempty($sht(vtp=>token::$tU))) {
    xlog("L_INFO","Successfully stored $sht(vtp=>token::$tU) for $tU on $ua\n");
  } else {
    xlog("L_INFO","Did NOT Successfully store $sht(vtp=>token::$tU) for $ua\n");
    return;
  }

  $var(joincounter) = 1;
  while ($shtcn(vtp=>%~join::$tU) > 0) {

    $var(hjoin) = $sht(vtp=>join::$tU-$var(joincounter));
    $var(hstored) = $sht(vtp=>stored::$tU-$var(joincounter));
    $sht(vtp=>join::$tU-$var(joincounter)) = $null;
    $sht(vtp=>stored::$tU-$var(joincounter)) = $null;
    if ($var(hjoin)==0){
      if ($var(hstored))
        ts_append("location", "$tU");

      #return;
    }
    $var(id_index) = $(var(hjoin){s.select,0,:}{s.int});
    $var(id_label) = $(var(hjoin){s.select,1,:}{s.int});
    xlog("L_INFO","resuming trasaction # $var(joincounter) -> [$var(id_index):$var(id_label)] $tU:$var(hjoin)\n");
    t_continue("$var(id_index)", "$var(id_label)", "LOCATION");
    $var(joincounter) = $var(joincounter) + 1;

  }
}

# lookup and relay after resuming transaction
route[INVRESUME] {
  lookup("location");
  # t_relay();
  ts_store();
  $sht(vtp=>stored::$rU) = 1;
  xlog("L_INFO","stored transaction [$T(id_index):$T(id_label)] $fU =>$rU\n");
  route(RELAY);
}
#!endif

# Presence server processing
route[PRESENCE] {
  if(!is_method("PUBLISH|SUBSCRIBE"))
    return;

  if(is_method("SUBSCRIBE") && $hdr(Event)=="message-summary") {
    route(TOVOICEMAIL);
    # returns here if no voicemail server is configured
    sl_send_reply("404", "The destination you dialed is invalid or no longer in service");
    exit;
  }

#!ifdef WITH_PRESENCE
  if (!t_newtran()) {
    sl_reply_error();
    exit;
  }

  if(is_method("PUBLISH")) {
    handle_publish();
    t_release();
  } else if(is_method("SUBSCRIBE")) {
    handle_subscribe();
    t_release();
  }
  exit;
#!endif
        
  # if presence enabled, this part will not be executed
  if (is_method("PUBLISH") || $rU==$null) {
    sl_send_reply("404", "Not here");
    exit;
  }
  return;
}

# Authentication route
route[AUTH] {

#!ifdef WITH_AUTH

#!ifdef WITH_IPAUTH
  if((!is_method("REGISTER")) && allow_source_address()) {
    # source IP allowed
    return;
  }
#!endif

  if (is_method("REGISTER") || from_uri==myself) {
    # if (is_method("REGISTER")) {
#!ifdef WITH_AUTH
    #   if (!is_subscriber("$tu", "subscriber", "3")) {
    #     xlog("L_ALERT","ERROR: Did not find subscriber To: $tu -> LOGTAG");
    #   }
#!endif
    # } else {
#!ifdef WITH_AUTH
    #   if (!is_subscriber("$fu", "subscriber", "3")) {
    #     xlog("L_ALERT","ERROR: Did not find subscriber From: $fu -> LOGTAG");
    #   }
#!endif
    # }

    # authenticate requests
    if (!auth_check("$fd", "subscriber", "1")) {
      auth_challenge("$fd", "0");
      exit;
    }
    # user authenticated - remove auth header
    if(!is_method("REGISTER|PUBLISH"))
      consume_credentials();
  }
  # if caller is not local subscriber, then check if it calls
  # a local destination, otherwise deny, not an open relay here
  if (from_uri!=myself && uri!=myself) {
    sl_send_reply("403","Not relaying to unavailable party");
    exit;
  }

#!endif
  return;
}

# Caller NAT detection
route[NATDETECT] {
#!ifdef WITH_NAT
  force_rport();
  if (nat_uac_test("19")) {
    if (is_method("REGISTER")) {
            fix_nated_register();
    } else {
      if(is_first_hop())
        set_contact_alias();
    }
    setflag(FLT_NATS);
  }
#!endif
  return;
}

# Building Record Route Presets and other PUB/PRIV Variables
route[RECORD_ROUTES] {
  xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm route[RECORD_ROUTES] IN -> OUT Protocols = $pr -> $dP \n");
  if($du == $null || "$du" == "<null>"){
    $du = $ru;
    xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm route[RECORD_ROUTES] Null Destination URI, forcing R-URI: Now IN -> OUT Protocols = $pr -> $dP \n");
  }

  # Preset variables to prevent thread overlap, set to default SIP/TCP
  $var(in-port) = "LISTEN_SIP";
  $var(in-proto) = "tcp";
  $var(out-port) = "LISTEN_SIP";
  $var(out-proto) = "tcp";

 
  if (!strempty($pr)) {
    $var(in-proto) = $(pr{s.tolower});
  }

  # Determine which port/protocol we received. SCTP will need to be added later.
  
    switch($var(in-proto)) {
    case "wss":
      $var(in-port) = "LISTEN_WSS";
      break;
    case "ws":
      $var(in-port) = "LISTEN_WS";
      break;
    case "tcp":
      $var(in-port) = "LISTEN_SIP";
      break;
    case "tls":
      $var(in-port) = "LISTEN_TLS";
      break;
    default:
      xlog("L_INFO","Something isn't right, we shouldn't have an in-proto value of: [$var(in-proto)]\n");
      $var(in-port) = "LISTEN_SIP";
  }

  # Determine which port/protocol we are sending to. SCTP will need to be added later.
  
  if (!strempty($(du{uri.param,transport}))) {
    $var(out-proto) = $(du{uri.param,transport}{s.tolower});
  }

  switch($var(out-proto)) {
    case "wss":
      $var(out-port) = "LISTEN_WSS";
      break;
    case "ws":
      $var(out-port) = "LISTEN_WS";
      break;
    case "tcp":
      $var(out-port) = "LISTEN_SIP";
      break;
    case "tls":
      $var(out-port) = "LISTEN_TLS";
      break;
    default:
      xlog("L_INFO","Something isn't right, we shouldn't have an out-proto value of: [$var(out-proto)]\n");
      $var(out-port) = "LISTEN_SIP";
  }

  if($var(in-proto) == $var(out-proto)) {
    ## This should cover all transactions using the same protocol regardless of protocol.
    # record_route_preset("PUBLIC_IP:$var(in-port);transport=$var(in-proto)");
    # Not proud of this, but record_route_preset won't play ball with branches!
    insert_hf("Record-route: <sip:PUBLIC_IP:$var(in-port);transport=$var(in-proto)>\r\n");
    xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm route[RECORD_ROUTES] Single transport dialog: $var(in-port):$var(in-proto) -> $var(out-port):$var(out-proto) \n");
  } else {
    ## Protocol translation
    ## Should be: record_route_preset("OUTBOUND INTERFACE", "INBOUND INTERFACE");
    # record_route_preset("PUBLIC_IP:$var(out-port);r2=on;transport=$var(out-proto)","PUBLIC_IP:$var(in-port);r2=on;transport=$var(in-proto)");
    # Not proud of this, but record_route_preset won't play ball with branches!
    append_hf("Record-route: <sip:PUBLIC_IP:$var(out-port);r2=on;transport=$var(out-proto)>\r\n");
    append_hf("Record-route: <sip:PUBLIC_IP:$var(in-port);r2=on;transport=$var(in-proto)>\r\n");
    xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm route[RECORD_ROUTES] Message came in over $var(in-port):$var(in-proto) and we are sending it out over $var(out-port):$var(out-proto), setting Record-Routes accordingly.\n");
  }

  return;
}

# RTPEngine control and signaling updates for NAT traversal
route[NATMANAGE] {
  # xlog("L_INFO","route[NATMANAGE]: BEFORE: BEGIN mb\n$mb\nEND mb\n");

  if(defined $avp(destination_voicemail)) {
    xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm Destination voicemail detected\n");
  } 
  if(defined $avp(destination_stt)) {
    xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm Destination stt detected\n");
  }

  if(is_present_hf("Supported")) { remove_hf("Supported"); }
  if(is_present_hf("Require")) { remove_hf("Require"); }
  if(is_present_hf("Allow-Events")) { remove_hf("Allow-Events"); }
#!ifdef WITH_NAT
  if (is_request()) {
    if(has_totag()) {
      if(check_route_param("nat=yes")) {
        setbflag(FLB_NATB);
      }
    }
  }
  if ($tU == "transcribe"  ||
      $(tU{s.substr,0,6}) == "jlstt." ||
      $(tU{s.substr,0,6}) == "jrstt." ||
      $(tU{s.substr,0,5}) == "lstt." ||
      $(tU{s.substr,0,5}) == "rstt." ||
      $(tU{s.substr,0,6}) == "glstt." ||
      $(tU{s.substr,0,6}) == "grstt." ||
      $(tU{s.substr,0,6}) == "gbstt." ||
      $(tU{s.substr,0,10}) == "translate." ||
      defined $avp(destination_stt) ||
      defined $avp(destination_voicemail)) {
    xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm Call is for transcribe/lstt/rstt\n");
    $avp(destination_stt) = 1;
    $avp(destination_solves) = 1;
    $avp(recipient_solves) = 1;
#    if($avp(invite_rtcp_fb == 1)) {
#      if (is_method("INVITE|UPDATE") &&
#        $rb =~ "a=rtcp-fb:") {
    if(sdp_with_transport("RTP/SAVP") ||
       sdp_with_transport("RTP/SAVPF")) {
      $var(transport_protocol)="RTP/SAVP";
      $xavp(downstream=>transport) = "RTP/SAVP";
    } else {
      $var(transport_protocol)="RTP/AVP";
      $xavp(downstream=>transport) = "RTP/AVP";
    }
  }
  if(!(defined $avp(destination_voicemail || defined $avp(destination_stt))) &&
     !(isflagset(FLT_NATS) || isbflagset(FLB_NATB)))
    return;

# If there's no SDP, then there's no point in the rest of this
  if(has_body("application/sdp")) {
      # rtpproxy_manage("co");

      set_rtpengine_set("0"); # <-- Default RTPEngine set. Redundant but may have future applications.

    if(!(defined $avp(recipient_solves))) {
      $var(wlru2)=$ru;
      $var(whitelisted_rd)= $rd + ".solves.whitelist.enum.puc.network";
      if(dns_int_match_ip("$var(whitelisted_rd)","127.0.1.1")) {
        xlog("L_NOTIFY","$TF $pp $si:$sp [$ci:$cs] $rm route[SIPOUT]: Found $var(whitelisted_rd) == 127.0.1.1\n");
        $avp(recipient_solves)=1;
      } else {
        xlog("L_NOTIFY","$TF $pp $si:$sp [$ci:$cs] $rm route[SIPOUT]: Did not find $var(whitelisted_rd)\n");
        $avp(recipient_solves)=0;
      }
      $ru=$var(wlru2);
    }

    # Set RTP/AVPF for SOLVES requests
    # if (is_reply()) {
    #   if($avp(destination_solves) == 1 || $avp(recipient_solves) == 1) {
    #     sdp_remove_codecs_by_name("G722,opus");
    #   }
    # }

    # Must define custom pvars with initial values because they are thread specific, not call specific!
    $var(transport_protocol) = "";
    $var(reinvite) = 0;

    # if(is_method("INVITE|UPDATE") && is_request()) {
    # Can't forget about ACKs with SDP.
    if(is_request()) {
      if( !defined $xavp(downstream=>transport) || strempty($xavp(downstream=>transport)) ) {
        # We need to figure out the incoming SDP transport because this is a new dialog
        $var(reinvite) = 0;
        if(sdp_with_transport("RTP/AVP")){
          $xavp(downstream=>transport) = "RTP/AVP";
        } else if (sdp_with_transport("RTP/AVPF")){
          $xavp(downstream=>transport) = "RTP/AVPF";
        } else if (sdp_with_transport("RTP/SAVP")){
          $xavp(downstream=>transport) = "RTP/SAVP";
        } else if (sdp_with_transport("RTP/SAVPF")){
          $xavp(downstream=>transport) = "RTP/SAVPF";
        } else if (sdp_with_transport("UDP/TLS/RTP/SAVPF")) {
          $xavp(downstream=>transport) = "UDP/TLS/RTP/SAVPF";
        } else if (sdp_with_transport("TCP/TLS/RTP/SAVPF")) {
          $xavp(downstream=>transport) = "TCP/TLS/RTP/SAVPF";
        } else {
          $xavp(downstream=>transport) = "RTP/AVP";
        }

      } else {
        # this is a re-INVITE, flag to forego the SOLVES checking and use stored transports.
        xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm This is likely a re-INVITE from $rdir(name).\n");
        $var(reinvite) = 1;
      }
      if($var(reinvite) == 0) { 
        #SOLVES is NOT compatible with RTP/SAVPF and RTP/AVPF for rtcp-fb:, those lines _must_ be removed
        if($avp(destination_solves) == 1 || $avp(recipient_solves) == 1) {
          xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm NATMANAGE: Destination is SOLVES\n");
          sdp_remove_line_by_prefix("a=rtcp-fb:");
          if(sdp_with_transport("RTP/SAVP") ||
             sdp_with_transport("RTP/SAVPF")) {
            $var(transport_protocol)="RTP/SAVP";
          } else {
            $var(transport_protocol)="RTP/AVP";
          }
        } else {
          # Anything else needs to be RTCP feedback implicit
          if(sdp_with_transport("RTP/SAVP") ||
             sdp_with_transport("RTP/SAVPF")) {
            $var(transport_protocol)="RTP/SAVP";
          } else {
            $var(transport_protocol)="RTP/AVP";
          }
        }
          # Now we store the destination transport for requests to manage re-INVITEs properly
          $xavp(upstream=>transport) = $var(transport_protocol);
      } else {
        if($rdir(name) == "downstream"){
          # RE-INVITE is from Caller, so we set the transport-protocol to the upstream (callee) remembered value.
          xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm RE-INVITE from Caller, setting transport_protocol to $xavp(upstream=>transport)\n");
          $var(transport_protocol) = $xavp(upstream=>transport);
        } else if($rdir(name) == "upstream"){
          # RE-INVITE is from Callee, so we set the transport-protocol to the downstream (caller) remembered value.
          xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm RE-INVITE from Callee, setting transport_protocol to $xavp(downstream=>transport)\n");
          $var(transport_protocol) = $xavp(downstream=>transport);
        } else {
          # redundant, but why not?
          xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm Failed to get directionality, setting transport_protocol to blank\n");
          $var(transport_protocol) = "";
        }
      }
    } else if (is_reply()) {
      # We apparently can't trust RTPEngine to translate the transport so we have to force based on memory:
      if($rdir(name) == "downstream"){
        # Reply is to Caller, so we set the transport-protocol to the downstream (caller) remembered value.
        xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm Reply to Caller, setting transport_protocol to $xavp(downstream=>transport)\n");
        $var(transport_protocol) = $xavp(downstream=>transport);
      } else if($rdir(name) == "upstream"){
        # Reply is to Callee, so we set the transport-protocol to the upstream (callee) remembered value.
        xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm Reply to Callee, setting transport_protocol to $xavp(upstream=>transport)\n");
        $var(transport_protocol) = $xavp(upstream=>transport);
      } else {
        # Failed to get directionality, defaulting to blank.
        xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm Failed to get directionality, setting transport_protocol to blank\n");
        $var(transport_protocol) = "";
      }
    } else {
      # This really shouldn't be necessary. But it might be an ACK with SDP.
      xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm Not sure how we got here. Setting transport protocol to blank.\n");
      $var(transport_protocol)="";
    }
    xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm NATMANAGE: Setting upstream transport to $var(transport_protocol)\n");
    if($xavp(upstream=>transport) != $xavp(downstream=>transport) && !strempty($xavp(upstream=>transport))) {
      xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm SDP Transport Translation: $xavp(downstream=>transport) => $xavp(upstream=>transport) [$var(transport_protocol)]\n");
    }

    if(defined $avp(destination_voicemail)) {
      xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm Destination voicemail detected again\n");
    }
    if(defined $avp(destination_stt)) {
      xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm Destination stt detected again\n");
    }

    if ($tU == "transcribe"  ||
        $(tU{s.substr,0,6}) == "jlstt." ||
        $(tU{s.substr,0,6}) == "jrstt." ||
        $(tU{s.substr,0,5}) == "lstt." ||
        $(tU{s.substr,0,5}) == "rstt." ||
        $(tU{s.substr,0,6}) == "glstt." ||
        $(tU{s.substr,0,6}) == "grstt." ||
        $(tU{s.substr,0,6}) == "gbstt." ||
        $(tU{s.substr,0,10}) == "translate." ||
        defined $avp(destination_stt) ||
        defined $avp(destination_voicemail)) {
      xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm Call is for transcribe/lstt/rstt, we must media relay without ICE\n");

      if($rb =~ "a=rtcp-fb:") {
        xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm NATMANAGE: Removing rtcp-fb attributes\n");
        # strip rtcp-fb: attributes
        sdp_remove_line_by_prefix("a=rtcp-fb:");
      }
      xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm NATMANAGE: rtpengine_manage('RTP DTLS=passive ICE=remove replace-origin replace-session-connection $var(transport_protocol) address-family=IP4')\n");
      if(!rtpengine_manage("RTP DTLS=passive ICE=remove replace-origin replace-session-connection $var(transport_protocol) address-family=IP4")){
        route(RTPENGINE_DOWN);
      } else {
        route(RTPENGINE_UP);
      };
#     if(is_method("INVITE") && is_request()) {
#       if(is_request()) msg_apply_changes();
#         sdp_print("1");
#     }
    } else {
#!ifndef WITH_ICE
#     xlog("L_INFO","NATMANAGE: rtpengine_manage('RTP DTLS=passive ICE=remove replace-origin replace-session-connection $var(transport_protocol) address-family=IP4')\n");
#     if(!rtpengine_manage("RTP DTLS=passive ICE=remove replace-origin replace-session-connection $var(transport_protocol) address-family=IP4")){
#       route(RTPENGINE_DOWN);
#     } else {
#       route(RTPENGINE_UP);
#     };  
#     if(is_method("INVITE") && is_request()) {
#       if(is_request()) msg_apply_changes();
#         sdp_print("1");
#     }
#!endif

#!ifdef WITH_ICE
      if($rb =~ "a=candidate") {
  /* 
          JZ Note !!! -- Here we get a little fancy with RTPEngine. Making choices based on source protocol and specified transport.
                         Note that =~ "ws" will catch WSS as well.

                         WARNING!!! I usually use "media-address=PUBLIC_IP" with a variable substitution. 
                         Since it is possible that the Public IP of Kamailio does not match the host IP of RTPEngine, 
                         it will be crucial to rely on the "direction=priv direction=pub" labels, making sure these are specified on the RTPEngine container as well.
                         A $var(direction) pseudovariable set along with the record routes when determining the source and destination locations could be inserted here as well.
  */

        if( $proto =~ "ws" && ($ru =~ "transport=ws" || $(hdr(Record-Route)[1]) =~ "transport=ws") ) {
          xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm Call is going from a SIP host to a WebRTC user: $ru -> LOGTAG");
          if(!rtpengine_manage("ICE=force-relay replace-origin replace-session-connection DTLS=passive transport-protocol=UDP/TLS/RTPF/SAVP")){
            route(RTPENGINE_DOWN);
          }  else {
            route(RTPENGINE_UP);
          }
  #       if(is_method("INVITE") && is_request()) {
  #         if(is_request()) msg_apply_changes();
  #           sdp_print("1");
  #       }
        } else if ($proto =~ "ws" && 
                  ($ru =~ "transport=tcp" || 
                   $ru =~ "transport=tls" || 
                   $(hdr(Record-Route)[1]) =~ "transport=tcp" || 
                   $(hdr(Record-Route)[1]) =~ "transport=tls")) {

          xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm Call is going from a WebRTC user to a regular SIP transport: $ru -> LOGTAG");
          if(!rtpengine_manage("ICE=force-relay replace-origin replace-session-connection DTLS=passive SDES-no $var(transport_protocol)")){
            route(RTPENGINE_DOWN);
          } else {
            route(RTPENGINE_UP);
          }
  #       if(is_method("INVITE") && is_request()) {
  #         if(is_request()) msg_apply_changes();
  #           sdp_print("1");
  #       }
        } else if ($proto =~ "tls" && 
                  ($ru =~ "transport=tls" ||
                   $(hdr(Record-Route)[1]) =~ "transport=tls")) {

          if($avp(destination_solves) == 1 || $avp(recipient_solves) == 1 || $avp(source_solves) == 1) {
            if(!rtpengine_manage("RTP DTLS=passive ICE=remove replace-origin replace-session-connection $var(transport_protocol) address-family=IP4")){
              route(RTPENGINE_DOWN);
            } else {
              route(RTPENGINE_UP);
            } 
          } else {
            if(!rtpengine_manage("ICE=force-relay replace-origin replace-session-connection DTLS=passive $var(transport_protocol)")){
              route(RTPENGINE_DOWN);
            } else {
              route(RTPENGINE_UP);
            }
          }
  #       if(is_method("INVITE") && is_request()) {
  #         if(is_request()) msg_apply_changes();
  #           sdp_print("1");
  #       }
        } else {
          # Unencrypted SIP transports should not be allowing SDES
          if($avp(destination_solves) == 1 || $avp(recipient_solves) == 1 || $avp(source_solves) == 1) {
            if(!rtpengine_manage("RTP DTLS=passive ICE=remove replace-origin replace-session-connection $var(transport_protocol) address-family=IP4")){
              route(RTPENGINE_DOWN);
            } else {
              route(RTPENGINE_UP);
            }
          } else {
            if(!rtpengine_manage("ICE=force-relay replace-origin replace-session-connection SDES-no DTLS=passive $var(transport_protocol)")){
              route(RTPENGINE_DOWN);
            } else {
              route(RTPENGINE_UP);
            }
          }
  #       if(is_method("INVITE") && is_request()) {
  #         if(is_request()) msg_apply_changes();
  #           sdp_print("1");
  #       }
        }
      } else {
#!endif
        if(!rtpengine_manage("RTP DTLS=passive ICE=remove replace-origin replace-session-connection $var(transport_protocol) address-family=IP4")){
          route(RTPENGINE_DOWN);
        } else {
          route(RTPENGINE_UP);
        }
  #     if(is_method("INVITE") && is_request()) {
  #       if(is_request()) msg_apply_changes();
  #         sdp_print("1");
  #     }
#!ifdef WITH_ICE
      }
#!endif
    }

    # RTCP Feedback OFF support:
    # Remove rtcp-fb: attributes if called party doesn't support it.
    # Do this _after_ allowing rtpengine to re-write the SDP
    if(is_reply()) {
      if($avp(invite_rtcp_fb == 1)) {
        if($rb =~ "a=rtcp-fb:") {
          xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm NATMANAGE: Removing rtcp-fb attributes\n");
          # strip rtcp-fb: attributes
          sdp_remove_line_by_prefix("a=rtcp-fb:");
          if(is_request()) msg_apply_changes();
          sdp_print("1");
        }
      }
    }

    if (is_request()) {
      if (!has_totag()) {
        if(t_is_branch_route()) {
          add_rr_param(";nat=yes");
        }
      }
    }
    if (is_reply()) {
      if(isbflagset(FLB_NATB)) {
        if(is_first_hop())
          set_contact_alias();
      }
    }
#!endif

    if(is_request()) msg_apply_changes();
      sdp_print("1");
      # xlog("L_INFO","route[NATMANAGE]: AFTER: BEGIN mb\n$mb\nEND mb\n");
  }
  return;
}

# URI update for dialog requests
route[DLGURI] {
  xlog("L_NOTIFY","$TF $pp $si:$sp [$ci:$cs] $rm route[DLGURI]: Before du=$du -> LOGTAG\n");
#!ifdef WITH_NAT
  if(!isdsturiset()) {
    handle_ruri_alias();
  }
#!endif
  xlog("L_NOTIFY","$TF $pp $si:$sp [$ci:$cs] $rm route[DLGURI]: After du=$du -> LOGTAG\n");
  return;
}

# Routing to foreign domains
route[SIPOUT] {
  if (uri==myself) return;

  # When we route calls out, make sure we only allow a minimal set of SIP messages
  # Original header looks like this:
  # Allow: INVITE,ACK,CANCEL,BYE,MESSAGE,INFO,REFER,NOTIFY
  remove_hf("Allow");
  append_hf("Allow: INVITE,ACK,CANCEL,BYE,MESSAGE,INFO\r\n");
  # remove_hf("User-Agent");
  # append_hf("User-Agent: VTCSecure ACE Support SBC\r\n");

  route(RELAY);
  exit;
}

# PSTN GW routing
route[PSTN] {
#!ifdef WITH_PSTN
  # check if PSTN GW IP is defined
  # if (strempty($sel(cfg_get.pstn.gw_ip))) {
  #   xlog("L_NOTIFY","SCRIPT: PSTN routing enabled but pstn.gw_ip not defined -> LOGTAG\n");
  #   return;
  # }

  xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm PSTN route BEGIN\n");

  # If the From: user part is not a domestic US phone number...
  if(!($fU =~ "^\+?1?([0-9]{10})$")) {
    xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm SCRIPT: avp(fromnumber) = $avp(fromnumber)\n");
    if(!($avp(fromnumber) =~ "^\+?1?([0-9]{10})$")) {
      xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm SCRIPT: PSTN from User is not E.164 ($avp(fromnumber)) -> LOGTAG\n");
    } else {
      xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm SCRIPT: PSTN from User _is_ E.164 ($avp(fromnumber)) -> LOGTAG\n");
      #$fU = $avp(fromnumber);
      #if(is_request()) msg_apply_changes();
      xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm fU = $fU\n fu = $fu");
    }
  }

  xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm PSTN route verify e164\n");

  # If the Request URI user part is not a E.164 phone number...
  if(!($rU =~ "^\+?([0-9]{0,15})$")) {
    xlog("L_NOTIFY","$TF $pp $si:$sp [$ci:$cs] $rm SCRIPT: PSTN request User is not E.164 ($rU) -> LOGTAG\n");
    return;
  }

  $var(ru)=$ru;

  if(!defined($avp(fromnumber))) {
    if($fU =~ "^\+?([0-9]{0,15})$") {
      $avp(fromnumber) = $fU;
    }
  }

  xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm BEFORE enum pstn.enum.puc.network lookup: avp(fromnumber) = $avp(fromnumber)\n");

  # If the From user part is in the pstn.enum.puc.network zone, we trust it to make outbound PSTN calls
  if(!enum_pv_query("$avp(fromnumber)","pstn.enum.puc.network.")) {
    xlog("L_NOTIFY","SCRIPT: PSTN request User is not in PSTN enum zone -> LOGTAG\n");
    sl_send_reply("403", "PSTN calling is not available for your account");
    exit;
  }

  xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm AFTER enum pstn.enum.puc.network lookup: avp(fromnumber) = $avp(fromnumber)\n");

  $ru=$var(ru);

  # Try and route the call out through the PSTN gateway
  $rd = "pstn.puc.network";
  $rp = "5060";

  # We require things to be E.164 to get this far.
  ## route to PSTN dialed numbers starting with '+' or '00'
  ##     (international format)
  ## - update the condition to match your dialing rules for PSTN routing
  #if(!($rU=~"^(\+|00)[1-9][0-9]{3,20}$"))
  #  return;

  # only local users allowed to call
  #if(from_uri!=myself) {
  #  sl_send_reply("403", "Not Allowed");
  #  exit;
  #}

  #if (strempty($sel(cfg_get.pstn.gw_port))) {
  #  $ru = "sip:" + $rU + "@" + $sel(cfg_get.pstn.gw_ip);
  #} else {
  #  $ru = "sip:" + $rU + "@" + $sel(cfg_get.pstn.gw_ip) + ":"
  #                                + $sel(cfg_get.pstn.gw_port);
  #}
  $avp(pstncall) = 1;
  route(RELAY);
  exit;
#!endif

  return;
}

# XMLRPC routing
#!ifdef WITH_XMLRPC
route[XMLRPC] {
  # allow XMLRPC from localhost
  if ((method=="POST" || method=="GET")
      && (src_ip==127.0.0.1)) {
    # close connection only for xmlrpclib user agents (there is a bug in
    # xmlrpclib: it waits for EOF before interpreting the response).
    if ($hdr(User-Agent) =~ "xmlrpclib")
      set_reply_close();
    set_reply_no_connect();
    dispatch_rpc();
    exit;
  }
  send_reply("403", "Forbidden");
  exit;
}
#!endif

# Routing to voicemail server
route[TOVOICEMAIL] {
#!ifdef WITH_VOICEMAIL
  if(!is_method("INVITE|SUBSCRIBE"))
    return;

  if($avp(source_solves) == 1 || $avp(destination_solves) == 1 || $avp(recipient_solves) == 1 )
    return;

  # Voicemail Fix
  if(!(is_subscriber("$tu","subscriber", "3") || is_subscriber("$ru","subscriber", "3"))) {
    xlog("L_INFO","TOVOICEMAIL: Called party is not a subsctiber, do NOT send to voicemail server. Returning 404\n");
    sl_send_reply("404", "The destination you dialed is invalid or no longer in service");
    exit;
  }

  # check if VoiceMail server IP is defined
  if (strempty($sel(cfg_get.voicemail.srv_ip))) {
    xlog("L_NOTIFY","SCRIPT: VoiceMail routing enabled but IP not defined -> LOGTAG\n");
    return;
  }
  if(is_method("INVITE")) {
    if($avp(oexten)==$null) {
      xlog("L_INFO", "There is no oexten, considering to Request User: <$rU> if it is not null.\n");
      if($rU==$null)
        return;
      xlog("L_INFO", "There is no oexten, setting to Request User: <$rU>.\n");
      $avp(oexten) = $rU;
    }
    $ru = "sip:" + $avp(oexten) + "@" + $sel(cfg_get.voicemail.srv_ip)
                    + ":" + $sel(cfg_get.voicemail.srv_port);
  } else {
    if($rU==$null)
      return;
    $ru = "sip:" + $rU + "@" + $sel(cfg_get.voicemail.srv_ip)
                    + ":" + $sel(cfg_get.voicemail.srv_port);
  }
  xlog("L_INFO","Routing to voicemail at $ru\n");
  $avp(destination_solves) = 1; # So that we strip ICE in NATMANAGE.
  $avp(destination_voicemail) = 1; # So that we REALLY strip ICE in NATMANAGE.
  route(RELAY);
  exit;
#!endif

  return;
}


route[MWI] {
#!ifdef WITH_VOICEMAIL

  # Here we are going to generate a SUBSCRIBE to the VM_HOST and hope it responds with a NOTIFY that we can route to the user:

  # SUBSCRIBE sip:${user}@${vmail}:${port} SIP/2.0${cr}
  # To: <sip:${user}@${domain}>${cr}
  # From: <sip:${user}@${vmail}>${cr}
  # Date: ${date}${cr}
  # Call-Id: $(date +%Y%m%d%H%M%S)@${user}-phone.${domain}${cr}
  # CSeq: 1 $method${cr}
  # Contact: <sip:${user}@${domain}>${cr}
  # Event: message-summary${cr}
  # Expires: 100${cr}
  # Accept: application/simple-message-summary${cr}
  # Content-Length: 0${cr}


  xlog("L_INFO", "Generating SUBSCRIBE to VM_HOST:VM_PORT\n");

    # Basic UAC Request construction for SUSBCRIBE Message
  $uac_req(method) = "SUBSCRIBE";
  $uac_req(ruri) = "sip:"+$tU+"@VM_HOST:VM_PORT;transport=tcp";
  $uac_req(furi) = "sip:"+$tU+"@VM_HOST";
  # $uac_req(turi) = "sip:"+$tU+"@SIP_DOMAIN"; <-- This will require domain specific voicemail on the VM_HOST
  $uac_req(turi) = "sip:"+$tU+"@VM_HOST";
  $uac_req(hdrs) = "Date: " + $utimef(%a, %d %b %Y %H:%M:%S %Z) +
                   "\r\nEvent: message-summary\r\nExpires: 120\r\nAccept: application/simple-message-summary\r\n" +
                   "Contact: <sip:" + $tU + "@SIP_DOMAIN:LISTEN_SIP;transport=tcp>\r\n";
  $uac_req(evroute) = 1;
  uac_req_send();

#!endif
  return;
}


# SIP FORUM TWG6 VRS RS1.0 9.2.2.2
# "for INVITE requests received on the R1 interface and forwarded to a RUE,
#  the IP address of the RUE must be supplied in all non-100 provisional responses 
#  and successful final responses to the INVITE;"
route[TRSUSERIP] {
  if(status=~"1[0-9][1-9]" || 
     status=~"1[1-9][0-9]" ||
     status=~"[23][0-9][0-9]") {
    if(defined $avp(trsuserip)) {
      xlog("L_INFO","route[TRSUSERIP]: Appending Call-Info purpose=trs-user-ip with $avp(trsuserip)\n");
      if(!is_present_hf("Call-Info")) {
        append_hf("Call-Info: <sip:$avp(trsuserip)> ;purpose=trs-user-ip\r\n");
      }
    }
  }
}

#!ifdef WITH_CATAPULT

# SMS Routes for building and sending SMS messages to and from Bandwidth.com

route[SMS_SEND] {
  if($hdr(Content-Type) =~ "im-iscomposing") {
    xlog("L_INFO","$(C(ps))Provisional im-iscomposing message, ignoring!!!$(C(xx))\n");
    sl_send_reply("200","OK");
    exit;
  }
  # Send provisional response to stop re-transmits.
  sl_send_reply("100","Forwarding to SMS Relay");
  
  # TODO: Need a check for image tags to append URLs for MMS (Future Feature)
  $var(jsonsms) = $null;
  $var(res) = $null;
  $var(smsfrom) = $null;

  if(defined $avp(fromnumber)) {
    $var(smsfrom) = $avp(fromnumber);
  } else {
    $var(smsfrom) = $fU;
  }

  jansson_set("string", "from", "$var(smsfrom)", "$var(jsonsms)");
  jansson_set("string", "to", "$tU", "$var(jsonsms)");
  jansson_set("string", "text", "$rb", "$var(jsonsms)");
  jansson_set("string", "receiptRequested", "all", "$var(jsonsms)"); # none, all, or error
  # jansson_set("string", "callbackUrl", "https://SIP_DOMAIN:XHTTP_PORT/pucsms", "$var(jsonsms)");
  jansson_set("string", "callbackUrl", "https://SIP_DOMAIN:LISTEN_TLS/pucsms", "$var(jsonsms)");
  jansson_set("string", "callbackHttpMethod", "post", "$var(jsonsms)"); # get or post
  jansson_set("string", "callbackTimeout", "5000", "$var(jsonsms)");
  jansson_set("string", "tag", "cseq=$cs", "$var(jsonsms)");

  $var(res) = http_connect("bandwidth","/v1/users/BANDWIDTH_USER_ID/messages", "application/json", "$var(jsonsms)", "$avp(smsresult)");
  xlog("L_INFO", "Bandwidth API-server HTTP connection: $avp(smsresult) Result code $var(res)\n");
  if($var(res) == 201){
    xlog("L_INFO","Looks like our SMS went out, sending an OKAY back to the sender.\n");
    sl_send_reply("200","Message Sent");
    exit;
  } else {
    xlog("L_INFO","Looks like our SMS request failed, sending an ERROR back to the sender.\n");
    sl_send_reply("500","Message Failed");
    exit; 
    # Ideally we will provide more granual responses to failures. But for now all we need is a fail.   
  }
  
}

route[SMS_RECEIVE] {

  # Basic UAC Request construction for SIP Message
  $uac_req(method) = "MESSAGE";
  $uac_req(ruri) = "sip:"+$avp(to)+"@SIP_DOMAIN";
  $uac_req(furi) = "sip:"+$avp(from)+"@SIP_DOMAIN";
  $uac_req(turi) = "sip:"+$avp(to)+"@SIP_DOMAIN";
 
  if($avp(eventType) == "mms"){
    # $uac_req(hdrs) = "Content-Type: text/html\r\nX-SMS: Yes\r\n"; <-- We can't do this yet. Need a format that PUC will understand.
    $uac_req(hdrs) = "Content-Type: text/plain\r\nX-SMS: Yes\r\n";
    $avp(body) = $avp(text);
    # TODO: Iterate through $avp(media) and create appropriate tags in a format PUC will understand, for now we omit media.
  } else if($avp(eventType) == "sms") {
    $uac_req(hdrs) = "Content-Type: text/plain\r\nX-SMS: Yes\r\n";
    $avp(body) = $avp(text);
  }

  $uac_req(body) = $avp(body);
  uac_req_send();

  # TODO: Need to have reply route send reply as event to Bandwidth for read receipt eventually.
  $avp(sms) = 1;

}

#!endif

route[RTPENGINE_DOWN] {
  if(defined $sht(vtp=>RTPENGINE::open_incident)) {
    xlog("L_INFO", "RTPEngine is down, but incident $sht(vtp=>RTPENGINE::open_incident) is already open for this issue.\n");
  } else {
    $avp(pd_servicekey) = "RTPENGINE_SVCKEY"; ## Example: "6135330c6f9b41a0a81cc5a435ffca20";
    $avp(pd_description) = "RTPEngine is down for SIP_DOMAIN:\n RTPEngine Instance:" + $avp(rtpengine_rtp_instance) + " is unreachable.";
    xlog("L_INFO", "RTPEngine is down, sending event to PagerDuty with Service Key: RTPENGINE_SVCKEY\n");
    $avp(pd_event_type) = "trigger";
    route(PAGERDUTY);
    if(defined $avp(incident_key)) $sht(vtp=>RTPENGINE::open_incident) = $avp(incident_key);
  }
  return;
}

route[RTPENGINE_UP] {
  if(defined $sht(vtp=>RTPENGINE::open_incident)) {
    $avp(pd_servicekey) = "RTPENGINE_SVCKEY"; ## Example: "6135330c6f9b41a0a81cc5a435ffca20";
    xlog("L_INFO", "RTPEngine is back up, sending event to PagerDuty with Service Key: RTPENGINE_SVCKEY\n");
    $avp(pd_event_type) = "resolve";
    route(PAGERDUTY);
    if($var(res) == 200) $sht(vtp=>RTPENGINE::open_incident) = $null;
  }
  return;
}

route[PAGERDUTY] {
  # Send provisional response to stop re-transmits.
  # sl_send_reply("100","Forwarding to SMS Relay");
  
  $var(pdjson) = $null;
  $var(res) = $null;
  $var(pdresult) = $null;
  $avp(incident_key) = $null;
  
  # Resolve Sample
  # {
  #  "service_key": "e93facc04764012d7bfb002500d5d1a6",
  #  "event_type": "resolve",
  #  "incident_key": "srv01/HTTP"
  # }

  # Trigger Sample
  # {
  #    "service_key": "6135330c6f9b41a0a81cc5a435ffca20",
  #    "event_type": "trigger",
  #    "description": "RTPEngine is down",
  #    "details": {},
  #    "contexts": []
  # }

  jansson_set("string", "service_key", "$avp(pd_servicekey)", "$var(pdjson)");
  jansson_set("string", "event_type", "$avp(pd_event_type)", "$var(pdjson)");
  if($avp(pd_event_type) == "trigger"){
    jansson_set("string", "description", "$avp(pd_description)", "$var(pdjson)");
    jansson_set("object", "details", "{}", "$var(pdjson)"); 
    jansson_set("array", "contexts", "[]", "$var(pdjson)");
  } else {
    jansson_set("string", "incident_key", "$sht(vtp=>RTPENGINE::open_incident)", "$var(pdjson)");
  }

  $var(res) = http_connect("pagerduty","/generic/2010-04-15/create_event.json", "application/json", "$var(pdjson)", "$avp(pdresult)");
  xlog("L_INFO", "PagerDuty API-server HTTP connection: $avp(pdresult) Result code $var(res)\n");
  if($var(res) == 200){
    # {
    #   "status": "success",
    #   "message": "Event processed",
    #   "incident_key": "1e8783c7513c479fb47608dff1e11811"
    # }
    jansson_get("incident_key", "$avp(pdresult)", "$avp(incident_key)");
    xlog("L_INFO","Successfully sent $avp(pd_event_type) to PagerDuty Incident: $avp(incident_key).\n");
  } else {
    xlog("L_INFO","Looks like our PagerDuty event failed.\n");   
  }
  return;

}

#!ifdef WITH_REGIONS
route[CHECK_REGION] {
  # This is going to be ugly, but in order to check the headers from a curl response, I need to use a shell exec.
  $avp(region:response) = http_connect("regionapi","/api/Region?username=$rU", "application/json", "", "$avp(region:result)");
  xlog("L_INFO","http://api.DNS_DOMAIN:5000/api/Region?username=$rU returned: $avp(region:response) with: \n$avp(region:result)\n");
  switch($avp(region:response)) {
    case 200:
      jansson_get("Location", "$avp(region:result)", "$avp(region:location)");
      xlog("L_INFO","Got a 200 OK with location: $avp(region:location), handling...\n");
      if($avp(region:location) != "null") {
        $avp(region:parsed-loc) = "sip." + $avp(region:location);
        $avp(region:new-uri) = "sip:" + $rU + "@" + $avp(region:parsed-loc) + ":" + $rp;

      } else {
        xlog("L_INFO", "Location header is null, returning to normal route...\n");
        return;
      }

      # determining whether the returned location is this proxy...
      if(!is_myself("sip:" + $avp(region:parsed-loc))) {
        xlog("L_INFO", "$avp(region:parsed-loc) is not me, setting R-RURI to $avp(region:new-uri);transport=tcp.\n");
        $ru = $avp(region:new-uri) + ";transport=tcp"; 
      } else {
        xlog("L_INFO", "$avp(region:parsed-loc) is me, returning to normal route.\n");
        return;
      }
      
      if(is_method("REGISTER")) {
        xlog("L_INFO","This is a registration attempt that should go to $avp(region:parsed-loc), sending redirect...\n");
        # generate and send 302 redirect, Kamailio will use the modified R-RURI from above in the contact header.
        t_reply("302", "Found");
        exit;
      } else {
        xlog("L_INFO","Routing $rm to $avp(region:parsed-loc)\n");
        $du = $ru;
        route(RELAY);
      }

    break;
    case 404:
      xlog("L_INFO","Got a 404 Not Found, did not find $rU, returning to normal route.\n");
      return;
    break;
    default:
      xlog("L_INFO","'$avp(region:response)' is not an expected response, returning to normal route.\n");
      return;
    }
}
#!endif

# Manage outgoing branches
branch_route[MANAGE_BRANCH] {
  xlog("L_INFO","branch_route[MANAGE_BRANCH] -> [$T_branch_idx] to $ru -> LOGTAG\nBegin mb\n$mb\nEnd mb\n");

  xlog("L_INFO","branch_route[MANAGE_BRANCH] $TF $pp $si:$sp [$ci:$cs] BEGIN\n");

if(is_method("INVITE")) {
  # Set the fr_timer to timeout if there is no provisional response within 2 seconds to prevent 30 second delays on stale registrations.
  t_set_fr(36000, 10000);
} else {
  t_set_fr(36000, 36000);
}

#!ifdef WITH_HOMER
  if (!is_method("REGISTER")) {
    $var(before_du) = $du;
    $du = "sip:HOMER_SERVER:HOMER_PORT;transport=HOMER_PROTOCOL";
    forward();
    $du = $var(before_du);
  }
#!endif

  xlog("L_INFO","branch_route[MANAGE_BRANCH] $TF $pp $si:$sp [$ci:$cs] AFTER HOMER\n");

  if(!is_method("INFO|MESSAGE")) {
    xlog("L_INFO","branch_route[MANAGE_BRANCH] -> LOGTAG\n");
  }
    
    route(RECORD_ROUTES); ## <-- When there are multiple AORs with conflicting protocols, this prevents bad record_routes
    route(NATMANAGE);

  xlog("L_INFO","branch_route[MANAGE_BRANCH] $TF $pp $si:$sp [$ci:$cs] AFTER NATMANAGE\n");
    #route(TRSUSERIP);
}

# Manage incoming replies
onreply_route[MANAGE_REPLY] {
  if(!is_method("INFO|MESSAGE")) {
    xlog("L_INFO","onreply_route[MANAGE_REPLY] -> LOGTAG\nBegin mb\n$mb\nEnd mb\n");
  }

#!ifdef WITH_HOMER
  if (!is_method("REGISTER")) {
    $var(before_du) = $du;
    $du = "sip:HOMER_SERVER:HOMER_PORT;transport=HOMER_PROTOCOL";
    forward();
    $du = $var(before_du);
  }
#!endif

  ##### This does not appear to be necessary anymore
  # nWise injects a Record-Route: header item for their gateway that announces a ;lr with no transport, so UDP is assumed.
  # This impacts 200 OKs, causing return ACKs to attempt to be sent using UDP, which doesn't make it back to them correctly.
  # This removes the Record-Route header and disables the loose routing.
  ####remove_hf("Record-Route");
  if(status=~"[12][0-9][0-9]")
    route(NATMANAGE);
  #route(TRSUSERIP);
}
#!ifdef WITH_PUSH
failure_route[PUSH_FAILURE]{
  xlog("L_NOTIFY", "Looks like our push notification timed out.\n");

#!ifdef WITH_HOMER
  if (!is_method("REGISTER")) {
    xlog("L_NOTIFY","Passing through HOMER\n");
    $var(before_du) = $du;
    $du = "sip:HOMER_SERVER:HOMER_PORT;transport=HOMER_PROTOCOL";
    forward();
    $du = $var(before_du);
  }
#!endif

#!ifdef WITH_VOICEMAIL
  # serial forking
  # - route to voicemail on busy or no answer (timeout)
  # if (t_check_status("486|408")) {
  if(is_method("INVITE")) { 
    xlog("L_NOTIFY","Sending to Voicemail\n");
    $du = $null;
    route(TOVOICEMAIL);
    exit;
  }
#!endif

#!ifdef WITH_MSILO
  if ( is_method("MESSAGE") ){
    xlog("L_INFO", "MSILO: The downstream UA doesn't support MESSAGEs or has lost connectivity\n");
    # Failure replaces R-URI with the contact address, store with original R-URI of request.
    if($hdr(Content-Type) =~ "im-iscomposing") {
      xlog("L_INFO","$(C(ps))MSILO: Provisional im-iscomposing message, ignoring!!!$(C(xx))\n");
      t_reply("202","Accepted");
      exit;
    } else if ($mb =~ "is offline ***") {
      xlog("L_INFO","$(C(ps))MSILO: Failure on offline message notification, ignoring!!!$(C(xx))\n");
      t_reply("202","Accepted");
    } else {
      if (m_store("$ou")) {
        xlog("L_INFO", "MSILO: offline message stored\n");
        t_reply("202", "Accepted"); 
      } else {
        xlog("L_INFO", "MSILO: offline message NOT stored\n");
        t_reply("503", "Service Unavailable");
      }
    }
  }
#!endif

}
#!endif

# Manage failure routing cases
failure_route[MANAGE_FAILURE] {
  xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm failure_route[MANAGE_FAILURE]: Error class: $err.class level: $err.level info: $err.info rcode: $err.rcode err.rreason: $err.rreason -> LOGTAG\n");

  xlog("L_INFO","failure_route[MANAGE_FAILURE] -> LOGTAG\nBegin mb\n$mb\nEnd mb\n");

#!ifdef WITH_PUSH  
  if(t_branch_timeout()) {
    xlog("L_NOTIFY","$rm timed out, checking if we should send a push notification...\n");
    if($avp(sentpush) != 1){
      xlog("L_NOTIFY", "We haven't sent a push yet, let's try that first...\n");
      $avp(fail_ru) = $ru;
      $ru = $ou;
      $du = $ou;
      route(TRYPUSH);
    }
  }
#!endif

  if (t_check_status("415") && is_method("MESSAGE")) {
    xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm failure_route[MANAGE_FAILURE]: 415 Unacceptable\n");
    if ($hdr(Content-Type) =~ "text/html") {
        xlog("L_INFO","$TF $pp $si:$sp [$ci:$cs] $rm failure_route[MANAGE_FAILURE]: Converting from text/html to text/plain, then try to relay again\n");
        subst_hf("Content-Type","/text\/html/text\/plain/","a");
        $du = $avp(odu);
        route(RELAY);
        exit;
    }
  }

#!ifdef WITH_MSILO
  if ( is_method("MESSAGE") && (src_ip != myself || $hdr(X-SMS) == "Yes") && !($avp(destination_solves) == 1 || $avp(recipient_solves) == 1)){
    xlog("L_INFO", "MSILO: The downstream UA doesn't support MESSAGEs or has lost connectivity\n");
    # Failure replaces R-URI with the contact address, store with original R-URI of request.
    if($hdr(Content-Type) =~ "im-iscomposing") {
      xlog("L_INFO","$(C(ps))MSILO: Provisional im-iscomposing message, ignoring!!!$(C(xx))\n");
      t_reply("202","Accepted");
      exit;
    } else if ($mb =~ "is offline ***") {
      xlog("L_INFO","$(C(ps))MSILO: Failure on offline message notification, ignoring!!!$(C(xx))\n");
      t_reply("202","Accepted");
    } else {
      if (m_store("$ou")) {
        xlog("L_INFO", "MSILO: offline message stored\n");
        t_reply("202", "Accepted"); 
      } else {
        xlog("L_INFO", "MSILO: offline message NOT stored\n");
        t_reply("503", "Service Unavailable");
      }
    }
  }
#!endif

#!ifdef WITH_HOMER
  if (!is_method("REGISTER")) {
    xlog("L_NOTIFY","Passing through HOMER\n");
    $var(before_du) = $du;
    $du = "sip:HOMER_SERVER:HOMER_PORT;transport=HOMER_PROTOCOL";
    forward();
    $du = $var(before_du);
  }
#!endif

  route(NATMANAGE);

  if (t_is_canceled()) {
    exit;
  }

#!ifdef WITH_BLOCK3XX
  # block call redirect based on 3xx replies.
  if (t_check_status("3[0-9][0-9]")) {
    t_reply("404","Not found");
    exit;
  }
#!endif

#!ifdef WITH_VOICEMAIL
  # serial forking
  # - route to voicemail on busy or no answer (timeout)
  # if (t_check_status("486|408")) {
  if (t_check_status("[456][0-9][0-9]") || t_branch_timeout() || t_any_timeout()) {  
    xlog("L_NOTIFY","Sending to Voicemail\n");
    $du = $null;
    route(TOVOICEMAIL);
    exit;
  }
#!endif
}

#!ifdef WITH_XHTTP
event_route[xhttp:request] {
  set_reply_close();
  set_reply_no_connect();

  xlog("L_INFO", "HTTP Request Received -> LOGTAG\n");

#!ifdef WITH_WEBRTC
 # if ($Rp != LISTEN_WS && $Rp != LISTEN_WSS) {
 #   xlog("L_WARN", "HTTP request received on $Rp -> LOGTAG\n");
 #   xhttp_reply("403", "Forbidden", "", "");
 #   exit;
 # }

  if ($hdr(Upgrade)=~"websocket"
      && $hdr(Connection)=~"Upgrade"
      && $rm=~"GET") {

    xlog("L_INFO", "event_route[xhttp:request] WebSocket request found.\n");
    # Validate Host - make sure the client is using the correct
    # alias for WebSockets
    if ($hdr(Host) == $null || !is_myself("sip:" + $hdr(Host))) {
      xlog("L_WARN", "Bad host $hdr(Host) -> LOGTAG\n");
      xhttp_reply("403", "Forbidden", "", "");
      exit;
    }

    if (ws_handle_handshake()) {
      xlog("L_INFO", "event_route[xhttp:request] Switched to WebSocket handling.\n");
      # Optional... cache some information about the
      # successful connection
      exit;
    }
  } else {
    xlog("L_INFO", "event_route[xhttp:request] Not a WebSocket request\n");
  }
#!endif

#!ifdef WITH_WOOCOMMERCE
  if($hu =~ "^/woocommerce") {
    xlog("L_INFO","We've received a WooCommerce Sync User request: $hu [$(hu{s.select,1,?})]\n");
    $var(namespace) = $(hu{s.select,1,?}{param.value,namespace,&});
    $var(username) = $(hu{s.select,1,?}{param.value,username,&});
    $var(expiration) = $(hu{s.select,1,?}{param.value,expiration,&});

    $sht(woocommerce=>$var(namespace)::$var(username)) = 1;
    $shtex(woocommerce=>$var(namespace)::$var(username)) = $(var(expiration){s.int});

    xlog("L_INFO","Set woocommerce=>$var(namespace)::$var(username) = 1 (expires in $var(expiration) seconds)\n");
    xhttp_reply("200", "Ok", "", "");
    exit;
  }
#!endif

#!ifdef WITH_CATAPULT
  # NOTE: For us to receive SMS in general and queue SMS for unregistered users, 
  #       we must specify this URL to the assigned application of the phone number.
  #       We should be able to specify a single application called "SMS America" for puc.network
  #       and apply it to all numbers that point to puc.network. Same for other networks.

  if($hu =~ "^/pucsms") {
    xlog("L_INFO","We've received an SMS message from Bandwidth.\n");

    # Example JSON:
    # POST http://SIP_DOMAIN:XHTTP_PORT/pucsms 
    # { 
    #   "eventType":"sms", 
    #   "direction":"in", 
    #   "messageId": "{messageId}", 
    #   "messageUri": "https://api.catapult.inetwork.com/v1/users/{userId}/messages/{messageId}", 
    #   "from":"+13233326955", 
    #   "to":"+13865245000", 
    #   "text":"Example", 
    #   "applicationId":"{appId}", 
    #   "time":"2012-11-14T16:13:06.076Z", 
    #   "state":"received" 
    # }

    # Parse the JSON.
    jansson_get("eventType", "$rb", "$avp(eventType)");
    jansson_get("direction", "$rb", "$avp(direction)");
    jansson_get("messageId", "$rb", "$avp(MedsageId)");
    jansson_get("messageUri", "$rb", "$avp(messageUri)");
    jansson_get("from", "$rb", "$avp(from)");
    jansson_get("to", "$rb", "$avp(to)");
    jansson_get("text", "$rb", "$avp(text)");
    jansson_get("applicationId", "$rb", "$avp(applicationId)");
    jansson_get("time", "$rb", "$avp(time)");
    jansson_get("state", "$rb", "$avp(state)");

    if($avp(direction) == "in") {
      xlog("L_INFO", "New Message received from $avp(from) to $avp(to) with messageId $avp(messageId).\n");
      if($avp(eventType) == "mms") {
        xlog("L_INFO", "This is an MMS message, do we support these yet? Grabbing media element.\n");
        jansson_get("media", "$rb", "$avp(media)");
      }
      route(SMS_RECEIVE);
      xhttp_reply("200", "OK", "text/html", "<html><body>OK ­ [$si:$sp]</body></html>");
    } else if($avp(direction) == "out") {
      xlog("L_INFO", "Message Status: $avp(state) for sent message from $avp(from) to $avp(to) with messageId $avp(messageId).\n");
      # Do stuff here like send a read receipt or something...
      # Will require info from PUC on what constitutes the body of a read receipt.
      xhttp_reply("200", "OK", "text/html", "<html><body>OK ­ [$si:$sp]</body></html>");
    }


  }
#!endif

  xhttp_reply("404", "Not Found", "", "");
}
#!endif

onsend_route {
  xlog("L_INFO", "onsend_route[] $TF $pp Sending $snd(len) bytes from $sndfrom(sproto):$sndfrom(ip):$sndfrom(port) to $sndto(sproto):$sndto(ip):$sndto(port) - Begin buf\n$snd(buf)\nEnd buf\n");
}

event_route[uac:reply] {
  xlog("request sent to $uac_req(ruri) completed with code: $uac_req(evcode)\n");
}

#event_route[websocket:closed] {
#    xlog("L_INFO", "WebSocket connection from $si:$sp with id $ws_conid has closed\n");
#}

event_route[htable:expired:woocommerce] {
    xlog("woocommerce htable record expired $shtrecord(key) => $shtrecord(value)\n");
}
event_route[htable:expired:vtp] {
    xlog("woocommerce htable record expired $shtrecord(key) => $shtrecord(value)\n");
}
event_route[htable:expired:ipban] {
    xlog("ipban htable record expired $shtrecord(key) => $shtrecord(value)\n");
}
event_route[htable:expired:morph] {
    xlog("morph htable record expired $shtrecord(key) => $shtrecord(value)\n");
}
